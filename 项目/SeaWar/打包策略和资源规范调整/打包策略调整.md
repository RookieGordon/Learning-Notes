---
tags:
  - SeaWar/打包策略和资源规范调整/打包策略调整
  - mytodo
type: Project
project: SeaWar
projectType: Task
fileDirPath: 项目/SeaWar/打包策略和资源规范调整
dateStart: 2025-07-28
dateFinish: 2025-07-28
finished: true
displayIcon: pixel-banner-images/项目任务.png
---
# 打包策略
打包策略调整的核心目标就是——`包的颗粒度需要和包的大小相匹配`，更新频繁的资源，颗粒度小，更新少的资源，颗粒度可以适当大一些。
## UI模块
目前，UI模块都是按照模块来配置打包策略的，因此更新颗粒度可以做到以文件夹为单位的细颗粒度。
通过分析打包的Report文件发现，有几个模块存在贴图资源过大的问题（>2MB）
![[（图解1）UI模块中过大的bundle.png|600]]
仔细分析得出如下结论：
1. arena_img_bg_ct.png纹理图开启了mip map，增加了内存，需要修改！
### 资源交叉引用分析
通过F2R实现一个对交叉引用的分析工具。通过分析数据得出，有很多模块都存在交叉引用的情况。
![[（图解2）UI模块之间的交叉引用.png|520]]
之所以要处理交叉引用，有点两点原因：
1. 模块的交叉引用，破坏了模块之间的独立性；
2. 模块之间的交叉引用，会导致加载多余的资源；
另外，还有最重要的一点，需要验证
3. `模块之间的交叉引用，是否会导致热更变大。比如A改动了图集，那么引用图集的prefab也会变动？`
	可以确定的是，如果图集中，被prefab静态引用的子图删除了，那么prefab必然会发生变化。经过验证，新增或修改子图，只有图集本身会发生变化，引用图集的资源不会。
第三点，目前来说，没有一个合理的方法，来全流程避免跨模块引用，并且还要涉及到现有图集的重新划分，牵扯的范围比较大。
如果我们放宽松其他，只从第二点考虑。只要能够确保不过多加载多余资源，就可以简化处理交叉引用这个问题。并且分析数据发现，UI模块被交叉引用的，全部都是贴图资源。因此，只要能够保证贴图资源单独一个Bundle，就能够放过很多情况不用处理。比如，如下情况就是必须要处理的：
通过采集数据发现，IntelAtlas.png被很多其他模块引用
![[（图解3）Intel模块的交叉引用.png|580]]
结合bundle数据发现，IntelAtlas.png和一个纹理大图intel_img_bg.png是在一起的
![[（图解4）IntelAtlas的Bundle资源.png|490]]
这意味着，随便加载一个IntelAtlas中的子图，就需要加载一个0.7mb的bundle，这是不合理。
通过分析intel_img_bg的引用发现，其并不存在动态加载的需求。因此可以直接将其从现在的bundle拆出去




