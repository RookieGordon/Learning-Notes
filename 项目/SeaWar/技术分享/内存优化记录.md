1. # 背景
    

测试同学在跑测的时候，发现进出战斗会带来内存增长，这个是不合理的，这一块可能存在内存泄漏的风险，所以统一看了一下这一块的问题，并输出文档记录一下。

同时内存如果占用过高的话，通常也会带来“游戏闪退”、“卡顿”、“系统重启”等现象，其中每一个结果基本都对游戏的体验是致命的。

2. # 相关内容
    

3. ## 内存占用
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJhMmRkMTEwOTMzZDYzYWMwNzZhNDdjMjAxNDFhMGNfWDQwa0w5ZmZGOUd1QWJ5aFFZQUF1WTUxSG1ZZ0tWejNfVG9rZW46QUdrUmJoM256b25DWU14aVAzaGNhaTRlbkdkXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器。请注意，CPU 和 GPU 访问同一个 RAM。[[13]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-NghRdwvLnoTnccxnJspcBkc9nyb)

  

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NDllNTY1MDE5OTlmNDE0YTMxYWQyZTY5OGUwOWU2ZWVfTUM0a2k3aUdqZ1hCVnZvTnVpVk9sV0lnSDcwZ0VjUXpfVG9rZW46V3AwNWIyNEpFb3oxdTJ4MUhaUGNiV0hnbmdiXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

根据官方文章 Memory Usage On Device[[15]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-M69rdwAcmo8Nnyx7mDic0WjWngd) 与 使用内存剖析器分析应用程序的物理内存占用情况[[2]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-XvMHdDXIQocSAxxWaF5c1mj4nFd) 提到的内容，我们可以知道 **物理内存占用 = 应用程序常驻内存 + 应用程序压缩内存页**

  

不过介于Unity 无法在某些平台上追踪到压缩页的内存，所以这一部分会被统计到 Native或者Untracked Memory部分。同时对于Android来说，大多数机型并没有压缩页，所以也没有这部分的统计，有些带有zRAM的机型，压缩后的页被放在kswapd（非RAM）所以Unity也统计不到。所以对于Android来说，可以先不考虑应用程序压缩页的内容。

2. ## Unity Memory Profiler
    

为了分析内存，可以使用官方工具进行深度分析。

1. ### 学习资源
    

https://www.youtube.com/watch?v=Uuzd39AjFWQ&t=636s&ab_channel=Unity

新手可以观看官方14分钟视频[[9]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-XglFd9ZqNonG5TxM9myco4Rfn0g)或官方文档[[10]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-HvGWdvgQnoiYWKxz05McOSn5ndd)进行学习

2. ### 工具版本差别
    

旧版本MemoryProfiler(0.7.x)界面

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDExNTdiNTM2ZDAyOWZmMjM0NjU1YWFjMTlmYzBlYjJfVVhpV2xHajlWNGMyaE5jTk05ZllQTEQ1ZWlqUnVQOTdfVG9rZW46R2NGU2JsRWltb0d1Vnd4SHQ4Z2NaUGlkbjBiXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

新版本MemoryProfiler(1.x.x)界面

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzg5ZmJiZjhlYTRhZDk4MjVhM2ZmM2Y3NmVhZTNkYjdfRnBxaWZtMGlkUG01NEFjU3ZvWUZETVFPeFZmdTVPbUxfVG9rZW46TFhjbGJVNHlub3FneTR4d3gwZmNNeDZqbmhlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

3. ## 内存分类
    

了解了如何使用内存分析工具后，我们需要对内存占用进行一个分类，这样才能按照对应的模块逐一处理分析优化

这里总结了一下不同类型Unity内存占用分配使用情况(依据新版本的Memory Profiler规则进行整理)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNjNjYzZDAxYjkyY2NhNzg4NzM5YjFlMjY1YmNkZTdfcHpWTHJrd3doOGdqcFFRbmU3eXp2YUF1Tkg2V2xPYU5fVG9rZW46VHVLQ2I3OHNtbzUzQ1F4eGVBTWNLMFhBblFlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

对于不同内存，官方也给出了对应描述[[11]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-K4vydep8JoAOXVxTJ8acMcm9nBc) ，这里截取了核心的描述

|   |   |
|---|---|
|**Category**|**Description**|
|**Managed**|显示所有虚拟机和托管堆内存分配。托管堆包含与托管对象相关的数据以及为它们预留的空间。它由脚本垃圾回收器管理，因此任何不再有引用链指向根的托管对象都会被收集。此类别中的“预留”量如果需要的话可以快速重用，并且如果有新的分配适合其中一个空闲空间。|
|**Native**|显示Unity为不同原生对象内部分配的所有内存，包括场景对象（游戏对象及其组件）、资源和管理器、原生分配（包括原生数组和其他原生容器）、图形资产内存的CPU部分以及其他。这不包括图形内存，这部分会在单独的类别中显示。展开此组以查看Unity跟踪的不同类型的原生内存。 Unity对象子组显示应用程序中任何Unity对象（如着色器或Texture2D）所使用的内存。利用这些信息可以找到可以优化内存使用的区域；然后可以在Unity对象标签页中更详细地检查这些对象。 Unity子系统子组显示已安装模块或系统所使用的内存。你可以找到哪些模块使用了最多的内存，如果有些模块未被使用，可以通过卸载它们来减少应用程序所需的内存。|
|**Executables & Mapped**|显示应用程序构建代码所占用的内存，包括所有共享库和程序集、托管代码和本地代码。此数值在所有平台上尚未一致报告。您可以通过使用更高的代码剥离级别以及减少对不同模块和库的依赖来降低此内存使用量。|
|**Graphics (Estimated)**|显示图形驱动程序和GPU为可视化您的应用程序所使用的内存量。这些信息基于Unity内部对图形资源分配的跟踪。这包括RenderTextures、纹理、网格、动画以及其他由Unity或脚本API分配的图形缓冲区。使用“所有内存”选项卡来探索图形资源。并非所有这些对象的内存都在这一类别中体现。例如，启用了读/写功能的图形资源需要在CPU可访问的内存中保留一份副本，这会使它们的总内存使用量翻倍。使用“Unity对象”选项卡来探索Unity对象的总内存使用情况。此外，并非所有这类对象的内存都驻留在GPU内存中。内存分析器无法获取图形资源的确切驻留信息。|
|**Untracked**|由于平台特定要求、潜在的错误或其他内存跟踪中的空白，内存分析器目前还无法解释的内存。未跟踪内存的大小是通过分析进程中所有已分配的区域，并从中减去Unity内存管理器已知的部分来确定的。要更进一步地分析这部分内存，您需要使用特定于平台的分析工具。|

4. ## 官方优化建议
    

**官方文档：**

  优化移动游戏性能：来自Unity顶级工程师的性能分析、内存与代码架构小贴士[[1]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-Z5PjdQbOfouu53xrXL5cqMAxnAc)

- 降低内存垃圾回收（GC）
    
- 对象池（Object Pool）
    
- 缓存GameObjects和组件
    
- 选择正确的数据结构
    
- 使用哈希值、避免字符串
    

**官方读物：**

暂时无法在飞书文档外展示此内容

3. # Untracked Memory分析
    

对于Tracked Memory，我们能够很轻松地通过Memory Profiler获取到内存分布，检测内存泄漏，但是对于UnTracked Memory这一部分，Unity也不能够明确地知道是由哪一个模块/插件/资源引起的，所以这一部分排查起来会比较困难。

  

使用dev包测试后发现，在游玩一阵后，Untracked Memory这一部分大概就有约300MB左右的大小了，有时候会更严重，这一部分看起来是有问题的，所以为了确定是什么地方会造成增长，花了一点时间对这些模块进行排查。

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFlMmRiYTMzNTJmMGVhMmRkOGQwNjljYjA0YjU2OGJfYVV1Z3U1Vkh4YnMxcTNxVXlpdVdvUm9UcW02aHZhekVfVG9rZW46R0EzZGIyblA5b0REbnR4THhGUGNaalpZblhmXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

1. ## 官方解释
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ0NDFhYTU1ODg0MGQyOWE1MWU0NDc1Y2FmNDNmYmVfUU1LM01oY3JrMFNQRUVoUm0zWlJxZkpEemZMUG9WcXRfVG9rZW46VFpHY2J2dHpJb1VCSlF4Z2tSUmM1VkFIblRoXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

官方给出的Untracked Memory包含的内容[[16]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-CZ5Yd0tDTo4xTGxkZ5qcatGwnBg)：

- 通过本地插件或某些驱动程序分配的内存
    
- Mono 或 IL2CPP 类型元数据
    
- 可执行代码和 DLL 文件使用的内存
    

2. ## 测试方案
    

在登录前增加一个新的空场景，10秒之后切换到登录场景，对比俩个场景中的内存分布情况，查看Untracked Memory增长问题。

每次去除一个模块的初始化，测试对比Untracked Memory的降低情况，测试后得出数据

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YzEzNGU0MDQ2ZDgyYjhjZGIxODZkZDIyZTNmM2Y2OThfTzJLcXZ2aVhLazVsUDdLOVhJQ2xoS0xBWGVnbzJlRVhfVG9rZW46STBubGJWYmZab1lGYkR4enVsdmNRMWxIbmtjXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

3. ## 测试结果
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MTU0NTg5NTA3MjJmZmNiODk3YTdlZjczNzg3OTYxMjVfa1RaYU56aFNyM0hUYlFBMDN0RGp6a0Jub2I3a2tWc1RfVG9rZW46U2FHaWJBRXQwb2NXMWp4d2FtZGNuNEJKbnZlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

|   |   |   |
|---|---|---|
|**Initial**|30~80|这个是加载空场景就会消耗的，包括了Unity 引擎本身、Graphics 驱动、OS runtime 基础成本|
|**LuaEnv**|30+|Lua虚拟机消耗，可通过深度GC降低|
|**SDK**|10+|第三方SDK消耗|
|**Shadow Occlusion**|30+|渲染会消耗|
|**Font**|20+|字体消耗|
|**Particles**|≈ 30|特效消耗|

4. ## 测试结论
    

目前Untracked Memory的上涨是不可避免的，我们需要对整体untracked memory的上涨做监控，让其不要无限制地增长。

  

同时在我们力所能及的范围内，管理好我们的资源和环境，比如说**释放一些不必要的资源**与通过对**LuaEnv的GC**可以降低untracked memory的大小。

4. # 优化方案
    

为了做优化，我们需要先梳理一下项目中的代码框架和逻辑

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc0NGRmOTcxOWM1Yjg3YzQyZTEzNDQyODZhOWY4MGRfSGdzb3lmNE1sSnVuMnJsb2I5cjNQV2dyUkpaejBSN3NfVG9rZW46WTlvWmJoWE9Tb3l2SnN4dUpLTWM4NWtvbnRmXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

通过梳理代码框架逻辑，我们发现所有的调用最终调用到的是Yooasset的加载逻辑，而后就是AssetPool的管理以及AssetManager的管理，最后是一些ResLoader的管理。所以我们可以一步一步从下至上逐步看看有没有问题。

1. ## 修正BaseResLoader引用计数
    

通过阅读`BaseResLoder`相关的代码，发现对于引用计数的处理不够完善，缺少了一些逻辑。

  

以`ImageLoaderMgr`为例说明，对于引用计数的清理放在了 `RemovePreRef`中，而调用清理的逻辑只有在设置的时候会处理

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NGVhZmNlMTIxMGYzNzUyNWM4YjBjN2Q1NTFiMzIyNjdfMkVYSDdLSzdYUTlpQVE5Y2VKaHhrOHJxSHVINHRSMTBfVG9rZW46VFl2UWJvMmxmb0Jud1p4ZE93bmNaQXdRblhmXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

这样就导致如果对应的 `GameObject` 被销毁/放到对象池了，那么对应的引用是不会被移除释放的，这样的话会导致引用计数始终不正确，`ResLoader`始终持有对象引用，从而导致最后的`YooAsset`不能释放资源。

  

虽然也有`CheckUnUsingRef`这个接口作为保底来减除引用，但是这里会依赖到父对象的生命周期，例如如果在对象池中的话引用计数是不会减少的。同时对象池没有消除干净的话也会影响到引用计数的计算逻辑。

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTZkZDEzYTliOWVmYmIwNDVlYTExODZhNDgyZGMxNGFfcnVtZ2l6a3dwVzEzSGpGY1o3ajBheE5TVUpCcGFHRnVfVG9rZW46Uk9IcmJiU3dEb2xMN3F4SXNtYWNKbGVxbnFlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

为了修复这个问题，需要做俩个步骤：

1. 增加清理引用的接口，让外部（Lua侧）可以调用
    
2. 对于Lua侧的管理，需要新增接口，做为中间件进行调用，并在对象生命周期结束时调用1)中的接口释放引用
    

  

这里的逻辑放置到了`SetSprite`上，当`address`为空字符串的时候触发释放资源引用的逻辑

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYzMDYyZmUxNDA2M2VlM2FhY2IxYTIzNzQ4ZGY2YjdfT2JZelVvWEJ5Q2lrb3pxNUphUUtiWjlDeE9wa0FFV0VfVG9rZW46SlN0VGJsY2tWb1JpR1l4a0xiUGM5aUxhbkdkXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

在Lua侧，新增了基类接口，并使用正则匹配修改所有调用地方

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI0NGRlYjZhZGVlYTBhYzYyZGRkNWZhZGRhNjdhMjNfalduQVVmRzZoQzI5YmhUWTJ1TlpXVjc4OXN2UW9XODBfVG9rZW46Qk0yRGJTRkx4b0tyaWt4c2ltSmNEMmZnbm9nXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

并增加移除接口，在生命周期结束时调用，不会增加开发负担

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc1OTg4MmU3ZGEzMmIyMzYzMzZhY2QxMzJlMzZlMjVfR3dZRWdOdkllWkFKZTNoMlhGYUFIdG5hc1BuY1VZTXpfVG9rZW46SlBBcGI5bUl0b2VyeE54Q1oxUmNtZjYzbmRiXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

通过对引用计数的修复，我们就能保证`ResLoader`这一块不会hold住不需要的资源，让`YooAsset`能够正确释放了。

2. ## AssetManager改造
    

`AssetManager` 中存在`UnloadUnusedAssets`的接口，但是只在没有资源使用的时候会清理，这里的判断仅在没有资源使用的时候会移除，会存在一点问题，只要pool有任意资源在使用，这个pool就不会有清理或收缩逻辑

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg2OTE2ODJiNzY1N2U0OTMxY2ZmNjEwZWFjZTY3ZTRfMWVRYWx3NmhRTFptdUNBTkZhSWVQUGh5cWw1c1F4ZVlfVG9rZW46RkRCMWJrUTdCb3EyUHR4aVV0MmMyelUwbmpjXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

为了解决这个问题，新增了一个收缩pool的方法，同时增加了依据这个pool最后使用的时间排序，这样在收缩的时候会优先清理最晚没有使用的资源，并提供了形参，用于控制需要gc的大小

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA1ZmQ1NGVkYjkyMzc2Njk3MzgzNjA5NTk1YWUwNzJfSTZ6T1V3eGN6UTJLVEZJN1JxZklPN3ZlQlBzU1BnakNfVG9rZW46RzJ1cmJEc1E4b2Nzdzh4c2YyTGN3NThUbjlkXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

3. ## 对象池改造
    

对象池的逻辑比较粗糙，仅有当引用计数清零的时候才会清理对象池

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFlZTAyZTJjYTBiZWQ5ZWM4NzM5YWY3YjlmOGFiNGVfakJHZlc4QzJoOEtPakd1amtPb2d2OFZhRkxQYWZ4STBfVG9rZW46TUNSd2I3MlFCb240NFl4UVdnamNiRnBpbk4zXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzc1NzdiNWY1MTJiZDkzOTliMzkyMzNhMzg5OGRiZjVfaTA5TGhoTDZwQUZES2pVd2dPc1NHSmNldmpyV3p1RnZfVG9rZW46WFczdWJQcGV5b0NPNlF4U2pvRWMzRHYwbm5lXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

这样会导致一个问题，如果这个对象池里面有10个对象，但是如果只要有一个对象在被使用中，剩下的9个未被使用的对象是不会被释放的，这里就会导致实例化的无用对象会占用一些内存。

  

为了解决这个问题，我们需要有一个收缩对象池的操作

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ5NDE4MmJhYWVhNGRjY2RiNzQ5Y2VmYjk2YmE0YWVfOUxYUjVJUmw0T0FhZHg3NnJOSTVOS2xKa1lvVVFBd1FfVG9rZW46WU83Z2JqMGNwb3ZBQXR4RG02VmM2aTA2bnp0XzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

这里会把没有使用到的实例化对象给销毁掉，对对象池进行收缩，从而降低对象池的占用内存大小。

4. ## PGAudioManager 清理
    

Lua中会使用PlaySFX来播放音效，这个时候走的是单独的音频管理模块

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YzhkYWRkMGQzZGVmOTMyYmZhMTRhMGM1ZWIyM2Y3YTZfcVBSQVYwOTlqWmpwZVpLSWxPQWhKSHZrakdHTzNtbFVfVG9rZW46VVh2NmJ1d3Vyb2J5RVF4SVJRZWNVQ3FvbmNmXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=OWM1OWE5MTU3MDgwMjRlOTZkZGQ2YWM5MmVhZDUwNzFfbG5waFNNZmZENWhIb1pOYUFTbWhWZFBwTjhmb0d3WmFfVG9rZW46Uk96U2JmOUxKb3ByQTV4Y2NZcWNMbFRqbktnXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

这里的 `PGAudioManager`中会hold住的资源，导致有引用释放不掉资源

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NDk3NTc3NzlmODI1NzIyOTg2MzhmYWIxYjM0MmI5MjNfeVFuYjM5VzVMZkJZOUNKeGZLdThYR0VzSlRiWW9pRnpfVG9rZW46TjFhRmJkZ2NrbzRVWml4TkVLUWNmeDBGbnZjXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

项目中的 PGAudioManager 虽然对各个容器大小做了限制，但是并没有一个清理逻辑，只能等满了的时候再去清理。这样就会导致有些可以在更早时间清理的内容会在后面才被清理掉。

  

所以在音频播放完成后，增加解除引用关联，避免长时间hold住资源引用

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFhZmFmZjBlYzM4YjMwNjFkOWU0YjRiN2U1NmY1MTZfTVhvYzJ3RTlCQXVqZGZ4cFdFWk50cHNUNFMycWdzM2tfVG9rZW46V0I1WGJ2bU5Gb0NsRXN4YlNVRGNqclNQbkhkXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

  

同时 `m_CacheHandler` 对于 `AudioClip` 的引用，并没有一个释放的逻辑，这样一旦加入到里面来之后，就不会被释放掉，所以这里也要增加一个解引的操作与收缩池子的操作。

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YWRhYzc1YjgwODczOTQ1MGYyYmJkM2ExMDFhNmQ5YzNfRkJ0SGZKRndrN2xTcDZwOVMyak5XMVRYcmN4UVdJVDBfVG9rZW46Uld4MWJUNndCb3JHblZ4M3lNc2NHdXVtbkNkXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

5. ## YooAsset Provider 清理
    

官方提供了正确的资源卸载范例[[5]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-Ei3QdvZsRovxQ6xDLfrcYtllnFb)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQzMDYxNDE5YjQ5ZjUyYjc0MjVhOWY2OGM2NWVhZTFfYlBNemxQdUFHUHhraGZ2RTlCZ3B1S3lpYVZmTFM0ZzdfVG9rZW46VHNpRGJoTzVjbzV3dW54bWk0eGNlN1NrbnZJXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

但是项目中并没有使用到对应代码去执行卸载逻辑。所以就会导致对应的资源一旦被YooAsset加载了，就不会被释放掉了，从而导致内存的不断增长。

为了解决这个问题，我们需要按照官方操作，加入卸载资源的代码。

```C#
var package = YooAsset.YooAssets.GetPackage("DefaultPackage");
yield return package.UnloadUnusedAssetsAsync();
```

6. ## LuaGC改进
    

在之前的分析中我们提到，Lua虚拟机会占用一些内存，如果Lua产生了很多垃圾，同时又没有及时地去清理，那么就会导致Lua虚拟机占用的内存会不断上升，从而导致内存占用上升。

  

Lua本身是带有GC的，只是GC的力度不是很大。如果每帧制造的垃圾超过了当前帧GC能够处理的垃圾上限，就会导致Untracked Memory上涨，从而导致内存占用上涨。所以在必要的时候我们需要对Lua进行一次深度的GC。

  

具体LuaGC相关的内容可参考Lua GC基础[[6]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-AH9pdIMDIoSST0xIK4RccwJvnUc)与lua5.4 分代垃圾回收[[7]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-CoAWdpp3Lom5Ysx5g3tcHtjmnyA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NmI4ODRiNDc3NTg4ZTZkNTMwNTc1NzBhYWUwYWRiNWVfT3A3RHBtUXRVWGxTOG11VEc5ZTRvT05lU0ZhR3h0MGJfVG9rZW46TG1meGIzbm1Cb0MxeFN4SkxpYWNpa2JlbnBkXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

同时官方也给出了相关文档来说明GC方式 官方Lua文档[[8]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-GF1pdWfIooZjvUx7au1czpzunXf)

  

我们就可以在必要的时候手动调用GC逻辑

```Lua
collectgarbage("step", size)           --增量GC，清除[size]kb的垃圾
collectgarbage("collect")              --做一次全量gc
```

7. ## MemorySystem 引入
    

在`GameManager`中，已经存在一个`Systems`的系统配置了，所以这里的内存管理系统也可以加入到这里统一进行管理

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNmN2ZhMzdhMzA3NWM3ZGQ4ZTk0MWUwZTQ0NTBjMjVfZUFnN1VKM2h2YTZQbndNWVZxNVN3VXpsc3AyUEc2R0ZfVG9rZW46WlNBa2JYNUpYb3ZPbzd4c3JlRGNMTUJYblpnXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

同时设计三种GC策略

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY4ZTFhN2I2YmMwYjZhMDJkNDYyYWM0YzMyNmJkMjFfRVdkUkhvalBvdGhDY0ZCeGJVMWZSTkxjbVpVb0tlMGNfVG9rZW46WHN4SGIyUThub0p1Qnp4UDBsVmNNdkdkbkZoXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

同时可以配置不同策略的触发阈值

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NWRhMDgxN2NhOGY4ZWRlZDk4ZmM4MjgyMzNiOGE3MzRfQ0dKSDZBQTFEelFHR1NOUkVERG13U2pGMXdiNHd1Sk1fVG9rZW46THowU2JwbUhkb3ljcU14QjhQR2N3TWk3bk5oXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

5. # 优化测试及数据对比
    

6. ## 测试环境
    

选取了俩个差不多时间的包进行测试（主干内容已合入分支后打的包）

|   |   |
|---|---|
|**测试版本：**|SeaWar-android_custom-bailixi_memory_leak-267.apk|
|**对比版本：**|SeaWar-android_custom-develop-262.apk|
|**测试账号条件：**|- 新号<br><br>- 货币 & 宝石 & 资源 超神<br><br>- 居民数量 6/6<br><br>- 主堡建筑 6级别<br><br>- chapter 3<br><br>- 区域解锁进度 0 0<br><br>- 解锁区域进度 0<br><br>- 全英雄满级|

2. ## 自测数据
    

测试了从登录到通关区域4，截取对应进度的内存情况进行对比分析，期间大概进行了15场战斗

|   |   |   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|---|---|
|**步骤**|**优化包**|   |   |   |   |**Dev****包**|   |   |   |   ||
||**Tracked**|   |   |**Untracked**|**Total**|**Tracked**|   |   |**Untracked**|**Total**|**Dif**|
||**Native**|**Managed**|**Graphics**<br><br>**(Estimated)**|**Untracked**|**Total**|**Native**|**Managed**|**Graphics**<br><br>**(Estimated)**|**Untracked**|**Total**|-|
|**登录界面**|227.1MB|16.7MB|79.6MB|165.6MB|489MB|271.3MB|20.2MB|79.8MB|142.7MB|514MB|-25MB|
|**进入家园**|369.2MB|25.7MB|105.4MB|196.7MB|697MB|364.2MB|30.1MB|105.6MB|186.2MB|686.1MB|10.9MB|
|**第一次进入战斗前**|375.2MB|26.4MB|107.7MB|211.7MB|721MB|370.2MB|29.5MB|106.9MB|207.3MB|713.9MB|7.1MB|
|**区域1通关后，未解锁前**|392.5MB|34.6MB|123.5MB|239.5MB|790.1MB|403.3MB|38.9MB|121.8MB|240.9MB|804.9MB|-14.8MB|
|**区域2通关后，未解锁前**|414.8MB|35.2MB|125.7MB|227.3MB|803MB|409.3MB|61.6MB|131.6MB|251.5MB|854MB|-51MB|
|**区域3通关后，未解锁前**|414.8MB|36.1MB|127.0MB|236.2MB|814.1MB|424.6MB|59.8MB|132.0MB|260.5MB|876.9MB|-62.8MB|
|**区域4通关后，未解锁前**|414.8MB|36.5MB|127.2MB|234.6MB|813.1MB|425.3MB|68.7MB|132.0MB|272.0MB|898MB|-84.9MB|

源文件：

暂时无法在飞书文档外展示此内容

1. ### 优化包第一次进入战斗前与测试完成后内存对比
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFlZDYwNjk5NDQyNTMzZThjOWFmZDcxYTQ5MzQ5ZGJfZmswc1dJWm1BUUNPVWJWd0VsSnM2MDg4NE9YZHpXSlNfVG9rZW46WTFpNmJyanFtb3R3bWd4QnI0YWNaNmlHbmtlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

2. ### dev包第一次进入战斗前与测试完成后内存对比
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA4NjFkNjhiZDc3ZjRmNjE4MWU2Nzc1MWU2MzIxZjhfM2pDUXZ1akF1eEJsaTN1dUVocHF2cTAwYnNVZHdFUE9fVG9rZW46RXVLQ2JZajM0b1VSYUR4UmdnTmN3WDlobkRnXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

3. ### 优化包与dev包测试结束后的内存对比
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MzViMWI5MGU0NjRhYjhkZWU4N2NhOGVkMzA4OWQzNzRfOHRKZlhYSTVJZ3lxM2JtU2h6N0llaURxVGF6eUVXVmZfVG9rZW46T2o2a2JwR0Zab2RaM3l4OTh4V2NxT1I2bkVjXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

可以看出，基于我们的内存池优化管理+`YooAsset`释放+`LuaEnv`深度GC，让Tracked Memory下降了约 47MB，同时也让Untracked Memory下降了约38MB，总占用内存下降约90MB。由此可见我们的优化方案是可行的。

3. ## 测试测试数据
    

> 【【老七优化需求】优化战斗内存问题，帧率问题】
> 
> [https://www.tapd.cn/tapd_fe/33063396/story/detail/1133063396001021978](https://www.tapd.cn/tapd_fe/33063396/story/detail/1133063396001021978)
> 
> 饼饼在状态 [已实现(负责人验收)] 添加
> 
> 进战斗之前内存是802，在5V5战斗局内第一局峰值会达到886M，第二局、第三局峰值会降到860这样，退出到主场景内存降至826，再次进战斗你内存峰值是853，再次退回到主场景，内存又降至827，战斗结束后内存有进行释放，重进战斗内存不会叠加增长
> 
> 测试数据连接：竞技场

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQwNDI5MjIyMzQ1Mjk3MjlmY2ZmYmUyNjQ5N2YxMDlfRUthS1RNWEFWYXFJbnhxV1RZU0hqTHhhMUFId0ZScUJfVG9rZW46U3VFU2JwcEdab1RsTHh4eXU4bmNwWjhTbmZlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

6. # 进一步策略调整
    

7. ## 内存阈值设置
    

上面的GC阈值是写死的配置 例如 600MB，这个不是很合理，比较不同机型能够占用的内存是不一样的，所以我们应该调整策略，获取到可以分配的内存最大值，根据这个值与阈值百分比去计算我们的实际GC阈值。

1. ### 可使用的内存上限
    

虽然官方建议的是不超过可使用内存的70% [[15]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-M69rdwAcmo8Nnyx7mDic0WjWngd)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDJkMjdmYTY5NTUwMjJjMGMxZjBiNzQ3MjdkNzdlMGVfQ2k3VWRjbkU2NmZPaDZaWG51aEUwZTFpRjNqNEhQb3FfVG9rZW46WEp3RmJZU1Zab1JDRGl4R1NpemNNWkRYbnowXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

但是根据UWA经验，对于4GB RAM而言，2000MB以上的PSS内存已经有可能导致项目在设备上的崩溃闪退，因此需要项目组对这样较高的PSS内存表现加以重视。[[17]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-D71TdGn0Uon0NUx1MzXcIVM9nnc)

2. ### 获取安卓分配内存
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MGMzMTczMjM2OTUwNThkYzFjODUyNmM1NTI0ZTFkMDhfcDJyS2pIQVBxa2phMEsxYWFRenZFVHQxMTJqYWkwMGhfVG9rZW46RFZvMmIybnA0b2JNRUN4YzJrQWN0emNVbjVlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

从写死的配置改为读取系统分配的内存 + 百分比配置

但是通过方法获取内存的逻辑不太可行，这里会返回512MB，在小米Mix2s(6GB)上，这个是不合理的

```C#
using (var unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
{
    AndroidJavaObject activity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
    AndroidJavaObject am       = activity.Call<AndroidJavaObject>("getSystemService", "activity");
    return am.Call<int>("getLargeMemoryClass");          // 单位：MB
}
```

如果采用 `<application android:largeHeap="true">` 的方式设置，又会涉及到获取大内存的问题，导致GC上升[[12]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-Vr50dNKnjogUvrxaTrmcsn7InZd)

看了一下其实这里获取到的并不是Unity应用的内存，而是 Java/ART 堆的内存大小，这一块只是Unity总内存的一部分

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGM3MDhmZmUyMzBkNmM1Zjg2ZWUyMzVmY2IzZGIwMTVfWGxTdFcyNFp0dVkxcTI0MzQzS1hYOWl6QmdsWVMzSUNfVG9rZW46WU1oYmJQcWRGb256N2t4Q0dDQWNHU24xbjlmXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

所以这里获取到的内容意义不是很大，需要采取其他方式来动态计算内存，例如

```Plain
TotalPSS / TotalMem + AvailMem
```

3. ### TODO: 寻找内存阈值设置方案
    

**TODO：**寻找内存阈值设置方案，目前先设置 1024MB 为最大值作为参考

2. ## 轻中重度GC策略调整
    

3. ### GC.Collect 策略
    

**作用域****：**托管堆

**释放对象：**仅托管对象（class、装箱结构体、托管数组等）

消耗：

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFlMTM1NTNhZmExNjM1NmViZjAzMTI1NDdkNjU1OTlfdEd5R2tZUlZhcG9yMTgwT1BYaFhrNktQUldjOFpnZ1dfVG9rZW46TWpZaGJuckpab3lZWlZ4RjJzNGNsd01ubmFlXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

`System.GC.Collect` 消耗大，不适合在轻度GC中使用，这里需要调整一下`System.GC.Collect`程度

官方机翻[[19]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-LryEdysRXoVLTuxAhNJceZpHn4f)

> GC 算法基于以下几个考虑：
> 
> - 压缩托管堆的一部分内存比压缩整个托管堆的内存更快。
>     
> - 较新的对象的寿命较短，较旧的对象的寿命较长。
>     
> - 较新的对象往往彼此相关，并且大约在同一时间被应用程序访问。
>     
> 
> 垃圾回收主要发生在短期对象的回收过程中。为了优化垃圾回收器的性能，托管堆被划分为三代：0、1 和 2，以便可以分别处理长期对象和短期对象。垃圾回收器将新对象存储在 0 代中。在应用程序生命周期早期创建且在回收后仍未消失的对象将被提升并存储在 1 代和 2 代中。由于压缩部分托管堆比压缩整个堆更快，因此这种方案允许垃圾回收器在每次执行回收时释放特定代中的内存，而不是释放整个托管堆的内存。
> 
> - 第 0 代：这一代是最年轻的，包含短生命周期的对象。例如，临时变量就是短生命周期对象的一个例子。垃圾收集在这一代发生得最频繁。
>     
>       新分配的对象构成新一代对象，并且隐式属于第 0 代集合。不过，如果它们是大型对象，则会进入大型对象堆 (LOH)，后者有时也称为第 3 代。第 3 代是物理代，在逻辑上作为第 2 代的一部分进行收集。
>     
>       大多数对象在第 0 代中被垃圾回收，并且不会存活到下一代。
>     
>       如果应用程序在第 0 代已满的情况下尝试创建新对象，垃圾回收器会执行回收操作，以释放该对象的地址空间。垃圾回收器首先检查第 0 代中的对象，而不是托管堆中的所有对象。仅回收第 0 代通常就能回收足够的内存，使应用程序能够继续创建新对象。
>     
> - 第 1 代：此代包含短寿命对象，并充当短寿命对象和长寿命对象之间的缓冲区。
>     
>       垃圾回收器执行第 0 代回收后，会压缩可访问对象的内存，并将它们提升到第 1 代。由于回收后仍保留的对象往往具有更长的生存期，因此将它们提升到更高的代是有意义的。垃圾回收器无需在每次执行第 0 代回收时重新检查第 1 代和第 2 代中的对象。
>     
>       如果第 0 代的收集没有为应用程序回收足够的内存来创建新对象，则垃圾收集器可以执行第 1 代的收集，然后再执行第 2 代的收集。第 1 代中在收集后仍保留下来的对象将提升到第 2 代。
>     
> - 第2代：这一代包含长寿命对象。例如，服务器应用程序中包含静态数据的对象，这些数据在整个进程运行期间都处于活动状态。
>     
>       第 2 代中在收集后仍保留的对象将保留在第 2 代中，直到确定它们在未来的收集中无法访问为止。
>     
>       大对象堆（有时称为第 3 代）上的对象也在第 2 代中收集。
>     
> 
> 垃圾回收会根据具体情况在特定代中进行。回收某一代意味着回收该代及其所有更年轻的代中的对象。第二代垃圾回收也称为完整垃圾回收，因为它会回收所有代中的对象（即托管堆中的所有对象）。

2. ### AssetManager 清理
    

**作用域****：**AssetManager管理的资源，包含对象池对象

**释放对象：**对象池实例化的资源、TextAsset、AudioClip 等资源

对于不同的GC程度设置不同的释放内存大小，轻度的尝试释放较少内存，重度的尝试释放较大内存

3. ### Lua collectgarbage 策略
    

**作用域****：**Lua虚拟机

**释放对象：**Lua(影响Untracked Memory)

Lua中提供了全量GC与增量GC的接口[[8]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-GF1pdWfIooZjvUx7au1czpzunXf)

```Lua
--增量GC
collectgarbage("step", 128)
--全量GC
collectgarbage("collect")
```

4. ### YoAsset UnloadUnusedAssetsAsync
    

**作用域****：**YooAsset加载的资源

**释放对象：**YooAsset加载的资源，同时也会降低Untracked Memory

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NjAzYWE4Nzk3MmU0MGZmNTExZDdlZTMwODk2MjYwZTBfdU9LZ2h0eEcycENvbm5oVnhhZjEwYTVkU25vUXR4b2NfVG9rZW46TldjY2J2MFMwb0JLcFh4WmdvN2MxTHIxbk1mXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

官方提供的接口中，默认的循环次数为10，这里涉及到引用链清理的逻辑，类似于红点树一样，要从底部逐步清理，循环次数越多的话，清理的强度也就越大，同时也会消耗更多的性能。

在不同的GC策略中，我们可以设置不同的循环次数，来调整GC强度。

3. ## 低内存处理
    

Unity提供了 `Application.lowMemory` 这个事件[[18]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-XC6bdVKzUoF930xfVPEcO9l0nzc)，走到这一步说明我们内存没有管理好，内存要爆炸了，得赶紧释放资源，不然会触发 LMK 机制

目前这一步还没有实现，在低端机中测试时我们目前的内存还是很低的，先观察一下。

7. # 后续优化
    

8. ## 增加记录内存峰值的模块
    

增加代码测试记录内存峰值，有利于后续内存分析

2. ## 减少GC
    

减少垃圾和GC [[3]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-HoFYdHnrqo00NCx0QLQcqUjAnee)

Unity 垃圾收集器原理[[4]](https://o455xcugsp.feishu.cn/wiki/MlhIwHKnEi8FSgkUQ1ncYUqQnce#share-OyVjd36T0o6FWgxI38mcmed3nye)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTk4NjZmZjE1NjhiM2EwMDU2Njk1MTY5MjUzMzc1YmZfbWVrTjVGTndGWGhjYnRGWUtLMnF0NVJtS2FxbXl1REZfVG9rZW46R2lkZWJFZFl2b2FMZ2x4ZjhzTGNzOVRWbnRjXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRhOWYyYzliMmQ5OWFjZGRlMTI5OGI3OGE0YjdlNmVfSVVTelM0UjQ0MzhDUWlwZFdIY05sN2hSUlBuRFJWVVdfVG9rZW46Q0dxNmJJUkpRb1Y5Nmd4ZElkamNHRDFQblNiXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ2YzA4MjU4NTI5NTdiN2FkZGRjMWNjNGYyZmMxMjdfN2NDZlBSVnlkUlhNVk55TkdPZWxnQ2VqbjRoRnhleUtfVG9rZW46QzNhaGJjY25qb3hsUXN4amNpVGN0QVhBbjBuXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

3. ## 动态GC时间调整
    

目前默认是30秒，后续需要动态调整GC时间，看看有没有较好的策略可以使用。例如帧率较高时可以延长一下gc时间的处理。

4. ## 整理一下LuaGC相关内容，输出文档，减少LuaGC
    

测试发现Lua Tick触发的GC并不能满足Lua侧垃圾清理的强度，得通过全量清理接口进行清理，说明这里有很大的空间可以进行优化

5. ## 看一下不同场景下内存占用的分配比例，对内存占用较大的资源进行记录整理和优化
    

测试中发现有些Font资源与Texture资源占用了很大的内存，这些东西是可以优化的，在后续的优化工作中可以先从这些大头开始进行优化处理。

8. # 有意思的点
    

9. ## 正则匹配全局替换
    

```Plain
^([ \t]*)([A-Za-z0-9._:"\[\]]+\.Image):SetSprite\((.*)
$1self:setSprite($2, $3
```

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDI0ODEzNjExNTc0ZTlhOTZiZTNlN2YxODQ3ODI1NzBfY0dHVGY1T2lQOVVNUGRNdURUeHpwT0JIeDVZTTJtNGxfVG9rZW46UjVXcWI2SjVKb2dTd1R4eGgzemMzY3prblpiXzE3NzAxODg4NDM6MTc3MDE5MjQ0M19WNA)

```Plain
^([ \t]*)([A-Za-z0-9. _:"\[\]]+):SetTexture\((.*)
$1self:setTexture($2, $3)
```

2. ## AI 参考
    

在查阅资料时使用到了ChatGPT与DeepSeak进行搜索，但是有时候AI的反馈不太可信，这个时候增加提示语，需要对于一些核心的观点和数据需要找到对应的引用，这样的话就有参考意义，能够提升搜索内容的可信度。

9. # 引用
    

[1] THOMAS KROGH-JACOBSEN / UNITY TECHNOLOGIES (2021年6月23日), "优化移动游戏性能：来自Unity顶级工程师的性能分析、内存与代码架构小贴士", Unity.com [Online]. 访问于: [https://unity.com/cn/blog/games/optimize-your-mobile-game-performance-tips-on-profiling-memory-and-code-architecture-from](https://unity.com/cn/blog/games/optimize-your-mobile-game-performance-tips-on-profiling-memory-and-code-architecture-from), 访问时间: 2025年7月11日

[2] ANTON KRUGLYAKOV / UNITY(2023年3月28日), "使用内存剖析器分析应用程序的物理内存占用情况", Unity.com [Online]. 访问于: [https://unity.com/cn/blog/engine-platform/analyzing-physical-memory-footprint-using-memory-profiler](https://unity.com/cn/blog/engine-platform/analyzing-physical-memory-footprint-using-memory-profiler), 访问时间: 2025年7月15日

[3] Unity(2018年3月5日), "Understanding the managed heap", Unity.com [Online]. 访问于: [https://docs.unity3d.com/2020.1/Documentation/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html](https://docs.unity3d.com/2020.1/Documentation/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html), 访问时间: 2025年7月15日

[4] Wikipedia, "Boehm garbage collector", wikipedia.org [Online]. 访问于: [https://en.wikipedia.org/wiki/Boehm_garbage_collector](https://en.wikipedia.org/wiki/Boehm_garbage_collector), 访问时间: 2025年7月15日

[5] yooasset(2025年), "资源卸载", yooasset.com [Online]. 访问于: [https://www.yooasset.com/docs/guide-runtime/CodeTutorial5](https://www.yooasset.com/docs/guide-runtime/CodeTutorial5), 访问时间: 2025年7月16日

[6] 可可西 (2023年11月12日), "Lua GC基础", cnblogs.com [Online]. 访问于: [https://www.cnblogs.com/kekec/p/14151606.html](https://www.cnblogs.com/kekec/p/14151606.html), 访问时间: 2025年7月16日

[7] 没有开花的树 Blog(2023年1月30日), "lua5.4 分代垃圾回收", cwqqq.com [Online]. 访问于: [http://cwqqq.com/2023/01/30/lua54_generational_collection](http://cwqqq.com/2023/01/30/lua54_generational_collection), 访问时间: 2025年7月16日

[8] lua(2020年), "Lua 5.3 Reference Manual", lua.org [Online]. 访问于: [https://www.lua.org/manual/5.3/manual.html](https://www.lua.org/manual/5.3/manual.html), 访问时间: 2025年7月16日

[9] Unity(2024年3月15日), "Memory Profiler Walkthrough & Tutorial | Unity", youtube.com [Online]. 访问于: [https://www.youtube.com/watch?v=Uuzd39AjFWQ&t=636s&ab_channel=Unity](https://www.youtube.com/watch?v=Uuzd39AjFWQ&t=636s&ab_channel=Unity), 访问时间: 2025年7月16日

[10] Unity, "Memory Profiler", docs.unity3d.com [Online]. 访问于: [https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html), 访问时间: 2025年7月16日

[11] Unity, "All Of Memory tab", docs.unity3d.com [Online]. 访问于: [https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/all-memory-tab.html](https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/all-memory-tab.html), 访问时间: 2025年7月16日

[12] 技术小黑屋 (2014年11月2日), "Note for Google IO Memory Management for Android", droidyue.com [Online]. 访问于: [https://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android/?utm_source=chatgpt.com](https://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android/?utm_source=chatgpt.com), 访问时间: 2025年7月16日

[13] Android Developer(2025年5月23日), "进程间的内存分配", developer.android.com [Online]. 访问于: [https://developer.android.com/topic/performance/memory-management?hl=zh-cn#:~:text=The%20Android%20platform%20runs%20on,processes%20and%20many%20user%20applications](https://developer.android.com/topic/performance/memory-management?hl=zh-cn#:~:text=The%20Android%20platform%20runs%20on,processes%20and%20many%20user%20applications), 访问时间: 2025年7月16日

[14] ownself(2023年3月19日) "Unity项目Android平台内存分析", ownself.org [Online]. 访问于: [https://www.ownself.org/2023/unity-memory-profile-on-android.html](https://www.ownself.org/2023/unity-memory-profile-on-android.html), 访问时间: 2025年7月16日

[15] Unity, "Memory Usage On Device", docs.unity3d.com [Online]. 访问于: [https://docs.unity3d.com/Packages/com.unity.memoryprofiler%401.1/manual/memory-on-device.html](https://docs.unity3d.com/Packages/com.unity.memoryprofiler%401.1/manual/memory-on-device.html), 访问时间: 2025年7月17日

[16] Unity, "Memory Profiler module reference", docs.unity3d.com [Online]. 访问于: [https://docs.unity3d.com/6000.1/Documentation/Manual/ProfilerMemory.html](https://docs.unity3d.com/6000.1/Documentation/Manual/ProfilerMemory.html), 访问时间: 2025年7月17日

[17] admin(2024年12月6日), "5000人测试背后的秘密｜GPM 2.0案例精讲", blog.uwa4d.com [Online]. 访问于: [https://blog.uwa4d.com/archives/UWA_GPM2_8.html](https://blog.uwa4d.com/archives/UWA_GPM2_8.html), 访问时间: 2025年7月17日

[18] Unity, "Application.lowMemory", docs.unity3d.com [Online]. 访问于: [https://docs.unity3d.com/6000.1/Documentation/ScriptReference/Application-lowMemory.html](https://docs.unity3d.com/6000.1/Documentation/ScriptReference/Application-lowMemory.html), 访问时间: 2025年7月19日

[19] Microsof Ignite (2023年2月28日), "Fundamentals of garbage collection", learn.microsoft.com [Online]. 访问于: [https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals), 访问时间: 2025年7月19日