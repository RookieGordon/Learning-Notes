# 优化场景

- 每个船队800个面，且有骨骼动画。带行军线+血条+攻击气泡,目标200个单位
    
# 优化方法

## GPU instancing

- 因为沙盘上船队大部分都是普通的船队，所以可以考虑把他们都用GPU Instancing来优化
    
- 遇到问题
    
        船队在不同的情况下有不同贴图，自己的是绿色贴图，盟友蓝色贴图，其他人红色，使用instancing的条件是材质需要相同
    
- 解决思路
    
        1.Texture Array
    
    ![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA0MzI2YmQ3YTU4ZjE4NjJlMDg4ZmEwNTExN2E1NWZfOHpjdmQwcnZCNmg4aTlUTmhZMzZkVjUyalVlM0F2TFRfVG9rZW46VmJ6WGJkRWljbzBYUGx4QkI1TmNEeHJlbnV3XzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MjBkOTk2MGM4MDdiMWNhZWFmMTllM2ExYjMwNDZlZWFfanZGNDB1c0VOQ24yaDZHSnpaTkF3Z1RYc2FGaGU3MENfVG9rZW46VENUMGJFS0dqb3BGTkZ4b3dtUWNtNXpkblpXXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWJlZDNkZDVmNGViYTBiOTQ1ZTUzZTQ5NzcxYjA5MzdfY0lGandvUXoyVjhDbDdEU0psdng5VHZCQjlCaTl4cDJfVG9rZW46TWZ6MWIybzVDb0I5SGR4eU5iVmNIODh1bnliXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=NzljMzYzN2NlOTYwZWI3MGNlODJmMzNhYjA0Yzc2NGNfUFhEcG04ZXoyZ0dMYzczVTRPMW1tZEVZck9kelhramdfVG9rZW46WjAyc2Jicmc3b3hQZnJ4M0dPaWNZVzJ6bktnXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkyNzgwZDZkZDYzNjNkY2ViYmNiOGNiZWQ1ZGJiZTdfS1luZkEzTUxyRFRrb1luNnRJdTJmSlo1MXJ6N0kzWndfVG9rZW46RmM0S2JxU0JBb2RWMkh4TVRhWWNCeHF6bmpoXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

  todo，

  每次最大批次

  设置texIndex改到c#

  mpb，传递确定要用的，数据结构简化。

  以上代码在SimpleLitTroop.shader

    2.打图集记录不同uv

## 顶点动画贴图Vertex Animation Texture

  船队的攻击动画是skin meshRenderer，不支持gpu instancing，所以要采用顶点动画或者gpu skinning的方式来播放动画。因为船队的炮台顶点比较少，动画比较简单，且ROA已经也用过顶点动画，所以这里也采取这种方式来实现。

- 使用
    

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YzljNmI1NTNlZGEzMzRhYWM2OTlhMjZhNjM4NjFmZDNfbFpMcE5ERENveHdpQ1BPdVhXMThiY1E2ZE9DYUZ3QVNfVG9rZW46QmI1VGJ2NGpJb0lRc0N4cW1hVWNYYmpNbm5oXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc0ZTg1NTllYmIyNjUyN2U1MjBkOTA1YTIxM2IxN2ZfYnViTDh2WGVtazZsc2F1TnJkTGxxNVpQMm44SUF1ODRfVG9rZW46TFVHZmJiaE9Vb3NZNzR4aWdNU2NZQ0xMblFlXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YWIzYjcyODVjYzlkZjAwNjk0Yzg3NTIzNjlmOGJhYmZfRmpJNWlyeVBBbnhMZEJ0dW5mOTQ3a2dSUnFkdG51dU9fVG9rZW46UzlwbmI4RVdNb2VZaGt4SExQNWNlamZvbkNlXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

- 基本原理
    
        把动画每一帧的顶点数据（法线，位置）烘焙到一张纹理中，一个像素存放一个顶点的位置信息，即把一个float存放到一个像素中，一般rgba16（每通道16位，支持负数）的精度就够了，在顶点着色器中对贴图直接进行采样，就可以在gpu通过采样贴图得到顶点的位置，消耗很低。
    
        VatCore.cs
    

  VATSimpleLit.shader

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MGMwZWY0MTZjNjI5YThlMGRlZDU4YmIxMTBkOGExZjVfYlIwWTBrdE9rdExBMkh2VDB3YWVXb3Vuck56UWNBUDNfVG9rZW46RmZGM2JEQW5wb0d0Uk14eEo4UGNWQThqbnVlXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

  缺陷，

    每个动画都是单独的贴图，所以需要不同的材质。可以优化成一张贴图，一个材质.

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=MGE4NDMwZWRkYzY3MTY5ZDdlNjA3ZTIzY2VhZTFjZTJfenBvd3hlaEREMVdkRWF2eXMxWWJuTTE3WGcwSE9zRTBfVG9rZW46RG1MR2JuVm5mb0R5dHF4RVQ2c2NVcVQ0bldmXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzc1ZDQwMTY2MjA1MGNjODI0Yzk3NTk5ODMwNzVmM2FfVGNPYzlmUXVXUm50TUdLQ0xzNnJxQjlhRHdUbUVKM3hfVG9rZW46UDN0cmJ2Z1Frb0lBRFJ4Rks2Y2M4THNZbktoXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)

  

  限制，

    如果顶点特别多或者动画帧数很长的话，导出的贴图会特别大，那么这时候就需要使用gpu skinning，该方法是烘焙的数据源是顶点的骨骼变换矩阵，然后再顶点着色器中采样贴图的矩阵进行对顶点进行变换，gpu计算消耗对比vat大一点，但是贴图内存会更小，因为瓶颈在于骨骼数量。

血条优化

  follow改成用精灵来渲染

  因为follow ui是ugui来渲染的，血条每帧变化需要每帧计算位置，且会造成canvas的rebatch，性能较差，所以改成了用SpriteAdvanceRenderer渲染，走的是动态合批。

- 缺陷
    
    - 目前场景需要实现填充ui元素大多数采用spriteAdvanceRender来实现，比如血条，行军线，这些脚本在实现效果的时候都是通过新生成顶点来做的，这就会导致cpu开销较大。
        
    
    ![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=YTI4ZTZiYmVhMGNmNGU1Y2I1YzU3Y2MxMjZkYTc5MGNfMFVGTGZIemg0b0NzbHJRZ2dRV2l1b0hTZjZ5NEVuWjBfVG9rZW46Vkh2OWI0UGd2bzJFSjJ4WU82QWNHWUc5bkliXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)
    
    - 目前缺陷渲染200个船队血条需要10ms左右
        
    
    ![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y1YjdkYjkxNmJhMDI1YzdkN2NhMjA3MjVhMGNlZGNfa3dMR1VMM1NXbnN5MUV4SEZGVjFCTTJ1WjlkZ1haOWVfVG9rZW46QTd1bGJvUkhYb2VZSXh4Q1hva2MxNUFlbmRjXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)
    
- 可优化思路，把每个SpriteRendere改用一个quad mesh，然后用gpu instancing来渲染
    
        测试数据，5ms左右
    
    ![](https://o455xcugsp.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjk1NjU5NGZiMDgyNTcyYmM2NDViNGM1NGFlMWIzNDRfTlQwNVB4Y09BaG12ZTJSQWR3c3NuOHZyRkNpa2FQbENfVG9rZW46TDJRdGJCeWRMb2ZYMTZ4WXlyVGM3ak45blVlXzE3NzAxODg2MzY6MTc3MDE5MjIzNl9WNA)
    

## 特效优化

- 精简了特效，每个特效的例子数减少至1-2个，之前是几十个
    

# 优化原理

- 我理解从图形api（openGL）,渲染一个网格要经历以下阶段
    

```C#
for (int i = 0; i < objectCount; ++i) {
    //绑定Mesh的顶点数据（VAO,VBO,EBO）
    
    //绑定贴图 glActiveTexture
    
    //绑定Shader glUseProgram 设置参数
    
    //调用DrawCall，（glDrawElements）
}
```

- static batching
    
    - 原理
        
        - 就提前把Mesh生成一大mesh
            
        - 按材质分批调用draw call
            
    
    ```OpenGL
    // 材质相同的mesh 1 2 3
    
    // 绑定贴图，shader
    
    // glDrawElements 1 2 3
    
    // 材质相同的mesh 4 5 6
    
    // 绑定shader，贴图
    
    // glDrawElemnts
    ```
    
    - 优点，
        
        - 可以减少drawcall
            
        - 减少api调用
            
    - 缺点
        
        - 内存增大
            
- dynamic batching
    
    - 原理
        
        - 在runtime对渲染队列里的mesh进行合并
            
    
    ```C#
    for (int i = 0 ; i < scene.mesh.count; i ++)
    {
      // 假设渲染队列相邻mesh能够合并，就合并到一起
    }
    // 对大mesh调用绑定vbo，vao
    
    // 绑定shader
    
    //调用draw call
    
    //继续下一次合并
    ```
    
    - 优点
        
        - 降低draw call
            
    - 缺点
        
        - 增加cpu的开销
            
- gpu instancing
    
    - gpu instancing是图形api层的一个优化，渲染的时候调用的api是不同的，调用的是glDrawElementsInstanced, 所以性能来说比前两种方式更快。
        
    - 假设渲染1000个mesh
        
    
    ```OpenGL
    for each mesh
      设置每个mesh的渲染属性 （变换，shad）
      
    绑定贴图 glActiveTexture
      
    调用一次，glDrawElementsInstanced
    ```
    
    - 优点：
        
        - 减少draw call，性能最高
            
    - 缺点
        
        - 限制较大
            
- srpbatcher
    
      伪代码
    
    ```C++
    // 传统渲染（每个物体都绑定材质常量缓冲）
    for (int i = 0; i < objectCount; ++i) {
        glUseProgram(shaderProgram);
        glBindTexture(GL_TEXTURE_2D, textures[i]);
        glBindBufferRange(GL_UNIFORM_BUFFER, 0, uniformBuffers[i], 0, sizeof(MaterialData));
        glBindVertexArray(vaos[i]);
        glDrawElements(GL_TRIANGLES, indexCount[i], GL_UNSIGNED_INT, 0);
    }
    
    //CBUFFER_START(UnityPerMaterial)
    //    half4 _BaseColor;
    //    half _minNl,_Lightness;
    //    sampler2D _BaseMap;
    // CBUFFER_END
    
    // SRP Batcher 渲染（批量绑定一个大常量缓冲，切换偏移）
    glUseProgram(batchShaderProgram);
    glBindBuffer(GL_UNIFORM_BUFFER, CBuffer);
    
    for (int i = 0; i < objectCount; ++i) {
        // 绑定顶点数组
        glBindVertexArray(vaos[i]);
        // 设置 Uniform Buffer 偏移 (通过 glBindBufferRange 或 glBindBufferBase + dynamic offset)
        glBindBufferRange(GL_UNIFORM_BUFFER, 0, CBuffer, i * sizeof(MaterialData), sizeof(MaterialData));
        glDrawElements(GL_TRIANGLES, indexCount[i], GL_UNSIGNED_INT, 0);
    }
    ```
    
    - 优点
        
        - 减少渲染状态切换，降低cpu的开销
            
        - 使用范围广
            
    - 缺点
        
        - 渲染大规模同样的物体较弱
            

todo，补充边界问题