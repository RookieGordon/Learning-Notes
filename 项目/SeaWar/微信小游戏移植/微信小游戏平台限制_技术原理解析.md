# 微信小游戏平台限制
## 技术原理深度解析

> 从 WebAssembly 沙箱机制到内存模型 · 从单线程调度到网络安全策略

本文档面向具有操作系统、浏览器体系结构、Unity 引擎内部原理基础知识的技术开发者。对于微信小游戏的每一项限制，文档将深入阐明其技术根因，而非仅列出限制本身——旨在帮助开发者建立正确的技术心智模型，从而制定合理的适配策略。

---

## 一、微信小游戏运行时架构概览

在深入理解任何具体限制之前，需要先建立对微信小游戏运行时分层架构的完整认知。微信小游戏既不是标准的浏览器 Web 应用，也不是原生 App，而是一个经过深度定制的封装环境——它在微信 App 进程内通过自定义 WebView/JSCore 引擎运行，同时又对外暴露了一套专有 API（wx API）替代标准浏览器 DOM/BOM。

```
┌─────────────────────────────────────────────────────┐
│         微信小游戏逻辑层  (JavaScript / V8 / JSCore)    │
│   wx.request   wx.downloadFile   wx.login   WX SDK   │
└─────────────────────────────────────────────────────┘
          ▼  JS ↔ Native Bridge（系统调用）  ▼
┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐
│   渲染层 (WebGL) │  │  网络层 (WKWebView│  │ 文件系统层   │
│  Canvas 2D/WebGL │  │  NSURLSession)   │  │ (UserData 目录)│
└──────────────────┘  └──────────────────┘  └──────────────┘
          ▼  Objective-C / Java Native Layer  ▼
┌─────────────────────────────────────────────────────┐
│   微信 App 进程   |   iOS / Android 操作系统           │
│   共享 JVM / OC Runtime   ·   共享内存空间             │
└─────────────────────────────────────────────────────┘
```

> 💡 **架构关键洞察**：微信小游戏运行于微信 App 进程内，而非独立进程。这是理解所有内存限制的基础：内存不仅被游戏占用，也被微信基础库（~130MB）、WebView 运行时、JS 引擎本身共享消耗。Unity WebGL 游戏通过 Emscripten 编译为 WebAssembly（.wasm），在 JS 引擎内以"虚拟 CPU"方式运行。因此 Unity 的所有代码执行、内存分配、GL 调用都在 JS 引擎的约束框架内进行。

---

## 二、包体大小限制的技术原理

### 2.1 限制参数

| 限制项 | 数值 | 技术原因 |
|--------|------|----------|
| 主包（首包）大小 | 4 MB | 冷启动预下载阈值 |
| 单个分包大小 | 4 MB | 与主包保持一致的下载单元限制 |
| 所有分包总大小 | 20 MB（普通）/ 30 MB（虚拟支付） | 本地持久缓存 I/O 性能保证 |
| CDN 远程资源 | 无硬性上限（受 200MB 本地缓存约束） | 网络延迟由 CDN 分发承担 |

### 2.2 为什么是 4MB？——冷启动时间模型

4MB 的主包上限并非随意设定，而是基于"秒开体验"的用户心理容忍模型推算出的阈值：

| 网络环境 | 典型带宽 | 4MB 传输时间 | 用户感知 |
|----------|----------|-------------|----------|
| 4G（良好） | ~15 Mbps | ≈ 2.1 秒 | 可接受 |
| 4G（一般） | ~5 Mbps | ≈ 6.4 秒 | 临界 |
| 4G（弱） | ~2 Mbps | ≈ 16 秒 | 流失风险高 |
| 5G | ~100+ Mbps | <0.5 秒 | 优秀 |

> ⚙️ **深层技术原因**：小游戏客户端在"点击进入"到"首帧渲染"之间，需要完成：网络下载主包 + 本地解压 + JS 引擎解析 + **WASM 编译**（JIT 或 AOT）+ Unity 引擎初始化。其中 WASM 编译是隐性耗时大头——一个 30MB WASM 代码文件在 iOS JavaScriptCore（无 JIT）上编译耗时可达 10+ 秒。4MB 的主包限制倒逼开发者将绝大部分逻辑移到运行时 CDN 加载，而不是打包进首包。

### 2.3 WebAssembly 编译内存的乘数效应

包体大小还与内存消耗直接相关，形成"下载大小 × N 倍内存"的乘数效应：

```
WASM 编译内存 ≈ WASM 代码文件大小 × 10 倍（iOS / Android 均适用）
示例：30MB WASM → 约 300MB 编译内存（临时峰值，编译后释放约 50%）
```

这解释了为什么"代码裁剪"（Strip Engine Code / Managed Stripping Level High）对移动端小游戏如此关键——它不仅减少下载大小，更直接削减 iOS 上最稀缺的内存资源。

---

## 三、单线程限制的技术根因

### 3.1 WebAssembly 的线程模型

这是整个移植工作中技术含量最高的限制，直接导致 Job System 无法并行、Burst 无法工作、Task.Run 崩溃。其根本原因需要从 WebAssembly 规范和浏览器安全沙箱两个层次理解。

**原因层次 1：WebAssembly 的 Managed GC 问题**

> ⚙️ Unity 的垃圾回收器（GC）在执行标记-清除（Mark-and-Sweep）阶段时，需要扫描所有线程的执行栈（Call Stack）和寄存器，以发现存活的对象引用。
>
> 然而 WebAssembly 的运行时规范规定：WASM 执行引擎不暴露对 WASM 执行栈的原生内存访问接口。这是出于安全性设计——每个 WASM 模块运行在自己的内存沙箱中，外部代码（包括 GC）不能随意读取其栈帧内容。
>
> **结论**：当存在多个执行线程时，GC 无法安全地扫描所有线程的栈，因此 Unity 的托管线程（System.Threading）在 WebGL 上被完全禁止。**这不是 Unity 的工程选择，而是 WebAssembly 规范级别的约束。**

**原因层次 2：JavaScript 引擎的 Event Loop 模型**

JS 引擎本身（V8 / JavaScriptCore）也是单线程的。JS 的并发模型基于 Event Loop——一个线程处理所有 JS 回调、Promise、WebGL 命令。

```
┌─ Call Stack（当前执行帧）────────────────────────────┐
│  executeFrame() → Update() → Render() → [BLOCKING]  │
└─────────────────────────────────────────────────────┘
       ← 当 Call Stack 为空时，Event Loop 才能处理下一个事件 →
┌─ Event Queue（等待队列）────────────────────────────┐
│  [网络回调] [requestAnimationFrame] [setTimeout] ... │
└─────────────────────────────────────────────────────┘
⛔  GC 也只能在 Call Stack 为空时（帧间隙）运行
    这是 WebGL 下频繁大量分配导致卡顿的根本原因
```

### 3.2 Burst 编译器为何完全不可用

> ⚙️ **Burst 的工作原理**：Burst 使用 LLVM 将 C# IL 在构建时编译为目标平台的原生机器码（x86 SSE4/AVX2、ARM64 NEON 等），提供 SIMD 向量化、循环展开、aggressive inlining 等低级优化。Burst 的性能优势完全依赖于对原生 CPU 指令集的直接访问。
>
> WebGL 的构建链路是：C# → IL2CPP（C++）→ Emscripten（LLVM 的 WebAssembly 后端）→ .wasm。LLVM 确实参与了这个链路，但 Emscripten 的目标是生成 WebAssembly 字节码，而 WebAssembly 是一种"虚拟指令集"（类似 JVM 字节码），不暴露 SIMD 寄存器（标准 WASM 不支持，WebAssembly SIMD 提案仍在推进中）。因此 Burst 依赖的 SSE/AVX/NEON 等 SIMD 指令在 WebAssembly 中无对应目标，**Burst 的 LLVM 后端根本没有 WASM 代码生成器**。

| | Native App（IL2CPP） | WebGL（Emscripten） |
|--|---------------------|---------------------|
| 代码路径 | C# → IL → IL2CPP C++ → Clang → native .dylib/.so | C# → IL → IL2CPP C++ → Emscripten → .wasm |
| Burst 优化 | ✅ LLVM 生成 SSE/AVX/NEON 指令 | ❌ 无 WASM SIMD 代码生成目标 |
| Job 并行 | ✅ Worker 线程真正并行执行 | ❌ Worker 数=0，同步主线程执行 |
| GC 执行时机 | 任意时刻可中断线程扫描 | 仅在帧间隙（Call Stack 空时） |
| 内存模型 | 虚拟内存 + 页表 + 按需扩展 | ArrayBuffer 线性内存，只增不减 |

---

## 四、内存限制的技术原理

### 4.1 iOS 内存分配层次模型

iOS 的内存限制最为严苛，是移植中最常导致上线崩溃的问题。

```
【iOS 设备物理内存：2GB（iPhone 7/8/SE2）/ 3GB（iPhone X/11）/ 4GB（iPhone 12+）】
  ▼ 减去：iOS 系统 + 内核 + 常驻守护进程（约 400–600MB）
  ▼ 减去：微信 App 基础库 + 微信逻辑（约 100–200MB）
  ▼ 减去：JS 引擎（JavaScriptCore）自身开销（约 30–50MB）
  ▼ 减去：WASM 编译后的机器码缓存（约 30–100MB，随代码体积变化）
  = 可供游戏使用的净可用内存
    2GB 设备 ≈ 500–700MB  |  3GB 设备 ≈ 900MB–1.2GB  |  4GB 设备 ≈ 1.5GB+
  其中游戏内存分配：Unity Heap + GPU 显存 + 音频缓冲 + JS Heap
```

> ❌ **为什么内存只增不减？**
>
> Unity WebGL 的内存模型基于 WebAssembly 的线性内存（Linear Memory）——一个单一的、连续的 `ArrayBuffer`。当 Unity 需要更多内存时，Emscripten 调用 `memory.grow` 指令扩展这个 ArrayBuffer。
>
> **根本问题**：ArrayBuffer 无法缩小。WebAssembly 规范未提供 `memory.shrink` 指令（仅有 `memory.grow`）。即使你卸载了所有 AssetBundle、触发了 GC，Unity Heap 的 ArrayBuffer 大小也不会减少。这意味着游戏的内存消耗是单调不减的——**内存峰值等于进程生命周期内的最大瞬时消耗，而非当前实际使用量**。
>
> 实践启示：控制内存的关键在于控制"峰值"，而非"稳态"。应避免同一时刻大量内存分配共存（如同时加载多个大 AB）。

### 4.2 Unity Heap vs GPU 内存的边界

| 内存区域 | 存储内容 | 谁管理 | iOS 崩溃时包含？ |
|----------|----------|--------|-----------------|
| Unity Managed Heap | C# 对象、Mono 运行时、GameObject 组件数据 | Unity GC | 是 |
| Unity Native Heap | Mesh 数据、Texture 像素数据（CPU 侧）、Audio PCM | Unity 引擎 | 是 |
| WASM 编译缓存 | 由 WASM 字节码 JIT/AOT 编译的机器码 | iOS JavaScriptCore | 是 |
| GPU 显存（WebGL RT） | Texture GPU 副本、RenderTexture、VBO/IBO | WebGL 驱动 | 是（共享内存架构） |
| JS Heap | WX SDK 对象、JS 胶水层临时分配 | V8 / JSCore GC | 是 |

> ⚠️ iOS 使用 UMA（统一内存架构）——CPU 和 GPU 共享物理内存。GPU 纹理占用大时会压缩 CPU 可用量，反之亦然。这正是 ASTC 纹理压缩在 iOS 小游戏上意义尤为重大的原因。

---

## 五、网络限制的技术原理

### 5.1 并发连接数限制（HTTP 10 个 / WebSocket 5 个）

| # | 约束来源 | 技术说明 |
|---|----------|----------|
| ① | HTTP/1.1 协议层 | 浏览器规范对同域名 HTTP/1.1 连接有 6 个并发限制（RFC 建议值），微信放宽到 10 但保留上限以防止资源耗尽 |
| ② | iOS 系统 NSURLSession | Apple 的 URLSession 对后台任务有系统级并发限制，大量并发下载会触发系统级任务队列 |
| ③ | 微信沙箱安全策略 | 防止小游戏通过大量并发请求消耗设备网络资源，影响微信本身的网络通信（如消息收发） |

### 5.2 域名白名单的技术实现

在微信后台配置的服务器域名白名单，通过以下技术链路进行强制执行：

```
游戏发起网络请求（wx.request / wx.downloadFile）
  ↓ 微信 Native 层拦截
    iOS：WKURLSchemeHandler
    Android：WebViewClient.shouldInterceptRequest
  ↓ 查询本地缓存的域名白名单（每次启动从微信服务器同步最新版本）
  ↓ 域名校验：URL 主机名是否在白名单中？是否 HTTPS？是否 ICP 备案？
  ✅ 通过 → 转发给 NSURLSession / OkHttp 执行真实网络请求
  ❌ 拒绝 → 返回错误码 -2（域名不在白名单），游戏收到 fail 回调
```

> 💡 **为何要求 ICP 备案？** 微信的设计哲学是将内容合规责任前置——要求域名完成 ICP 备案，本质上是借助工信部的备案审查机制来筛查恶意服务器（非法内容、诈骗、境外违规服务器等）。ICP 备案绑定了法人主体信息，一旦出现违规可溯源到真实运营主体。这是微信平台合规体系的组成部分，而非纯技术限制。

### 5.3 后台网络请求 5 秒超时的原因

游戏进入后台后，进行中的网络请求若 5 秒内未完成即超时。这与 iOS 的后台执行策略直接相关：

> ⚙️ iOS 系统对非前台进程的后台执行时间有严格限制。应用主动声明"Background Fetch"或"Background Processing"权限才能延长后台运行时间，但微信 App 并未为小游戏申请此类权限（以节省电量和内存）。
>
> 5 秒是微信小游戏引擎自定义的超时阈值（而非 iOS 系统值），目的是避免用户回到前台时面对一堆失败的请求堆积在队列中。正确的应对策略是在 `onHide` 事件中暂停下载队列，在 `onShow` 事件中恢复。

---

## 六、文件系统限制的技术原理

### 6.1 200MB 本地缓存的来源

| 因素 | 技术分析 |
|------|----------|
| 微信 App 自身存储 | 微信聊天记录、图片、视频已占用大量用户存储。如果每个小游戏都无限缓存，会导致微信整体存储膨胀，引发用户投诉 |
| iOS 存储沙箱策略 | iOS 规定 App 的 Documents 目录受用户可见，Library/Caches 可被系统在低存储时清理。200MB 是微信对游戏缓存使用量的主动限制 |
| LRU 清理机制 | 超过 200MB 时，微信自动按最近最少使用（LRU）策略清理旧缓存。这意味着游戏不能依赖文件永久缓存，必须有重新下载的容错逻辑 |
| 可扩展至 1GB | 提交申请后可扩容至 1GB——这说明 200MB 是默认保守值，非硬性技术约束 |

### 6.2 为什么没有标准文件系统 API

> ⚙️ **沙箱隔离原理**：微信小游戏运行在 JS 沙箱中，没有 Node.js 的 fs 模块，也没有浏览器的 File System Access API。微信提供了 `wx.getFileSystemManager()` 返回一个虚拟文件系统管理器，在物理上映射到 iOS/Android 的 App 沙箱目录（iOS：`~/Library/Application Support/WeChat/MicroApp/{appid}/`）。
>
> 对于 Unity/WebAssembly 而言，Emscripten 维护了一个内存中的虚拟文件系统（MemFS）用于模拟 POSIX 文件 API。当调用 `File.ReadAllBytes()` 时，实际读的是 WASM 内存中的 MemFS，而非磁盘。**这是为什么 `AssetBundle.LoadFromFile()` 在小游戏中并不节省内存——文件"读取"本质上是在 WASM 内存中拷贝，而非从磁盘 mmap。**

---

## 七、WebGL 渲染限制的技术原理

### 7.1 iOS WebGL 2.0 的特殊限制

iOS 的 WebGL 实现来自 Apple 的 WebKit 引擎，底层调用 Metal（Apple 自有 GPU API）。由于 Metal 与 OpenGL ES 的语义差异，WebGL → Metal 的转换层存在若干已知局限：

| 限制 | 数值 | 底层原因 |
|------|------|----------|
| DrawMeshInstanced 矩阵数 | ≤ 32 | Metal uniform buffer 的 per-draw-call 大小限制 |
| uniform 变量总数（Fragment Shader） | ≤ 1024 个 float | Metal 着色器 buffer 对齐限制 |
| Texture Unit 数量 | 16（WebGL 1.0）/ 32（WebGL 2.0） | Metal sampler 数量上限 |
| GLSL 版本 | 最高 GLSL ES 3.0（WebGL 2.0） | Metal Shader Language 转换兼容性 |
| Compute Shader | ❌ 不支持 | WebGL 2.0 规范本身不包含 Compute |

### 7.2 GL 调用链路与 EmscriptenGLX 优化

Unity WebGL 游戏的每一次 OpenGL 调用（如 `glDrawElements`）都经历一条冗长的调用链：

```
Unity C# → IL2CPP C++ 代码
  ↓ WASM 中的 GL stub 函数
  ↓ WASM → JavaScript 边界跳转  ← 性能热点！每次 GL 调用都有此开销
  ↓ JavaScript WebGL API 层（如 gl.drawElements()）
  ↓ 浏览器 / 微信 WebGL 驱动层
  ↓ 底层 GPU 驱动（Metal / OpenGL ES）
```

> 💡 **EmscriptenGLX 的优化原理**：微信团队开发的 EmscriptenGLX 技术将 GL API 的实现从 JavaScript 层移入 WebAssembly 内部。具体做法是：将 WebGL API 的 JavaScript 胶水层编译为 WASM，使 GL 调用在 WASM 内部完成，只在真正需要与 GPU 交互时才进行一次 WASM → Native 的跳转，而非每次 GL 调用都进行一次 WASM → JS 跳转。
>
> **效果**：减少了 WASM ↔ JS 边界切换次数。每次跨边界调用都涉及上下文切换（寄存器保存/恢复、JS 引擎状态切换），在高频 GL 调用场景（每帧数百次 DrawCall）下，这种优化可提升 10–20% 帧率，在中低端设备上更显著。

---

## 八、支付与安全限制的技术原理

### 8.1 iOS 不能在小游戏内直接支付的原因

> ⚠️ **Apple App Store 政策**：Apple 规定所有在 iOS App 内销售虚拟商品、数字内容和订阅服务，必须且只能通过 Apple 的 In-App Purchase（IAP）系统，并向 Apple 支付 15–30% 的抽成。
>
> 微信小游戏的米大师支付系统绕过了 IAP，使用微信支付直接向用户收费。如果允许 iOS 版微信小游戏直接内购，将违反 App Store 条款，导致微信 App 被 Apple 下架。
>
> **这并非微信自身的技术或政策限制，而是苹果生态系统规则的传导结果。** Android 版微信小游戏不受此约束，可正常调用米大师虚拟支付。

### 8.2 开放数据域隔离的安全模型

好友排行榜等需要访问用户社交关系的功能，必须在"开放数据域"（一个独立的 JS 沙箱）中运行：

| | 主域（游戏代码运行区域） | 开放数据域（隔离沙箱） |
|--|------------------------|----------------------|
| 能访问好友关系？ | ❌ | ✅ |
| 能访问 wx 网络 API？ | ✅ | ❌ |
| 能访问 WebGL / Canvas？ | ✅ | ✅（SharedCanvas） |
| 数据流向 | 只能向开放数据域写入 CloudStorage | 读取好友数据，结果只能渲染到 SharedCanvas |

> 💡 **隔离的意义**：如果游戏主代码可以直接访问用户的好友列表，恶意游戏可以收集社交关系图谱并上传服务器，构成严重隐私泄露。开放数据域的隔离架构在技术层面保证了：好友数据只在 JS 隔离沙箱内流动，外部（包括游戏服务器）无法接触这些数据。这是隐私安全设计模式"最小权限原则"的典型实践。

---

## 九、原生 Socket 不可用的技术原理

这是游戏服务器通信改造中最根本的约束。原生 TCP/UDP Socket（`System.Net.Sockets`）在微信小游戏中完全无法运行，不是"受限运行"，而是系统调用层面的完全拦截。理解这一限制需要从操作系统系统调用、Emscripten 编译层、浏览器安全沙箱三个层次分析。

### 9.1 根因层次一：WebAssembly 的系统调用隔离模型

> ⚙️ **WASI 与浏览器沙箱的根本差异**
>
> 原生应用（iOS App、Android App）调用 TCP Socket 的路径是：应用代码 → 系统调用（`syscall socket/connect/send`）→ 内核网络栈（TCP/IP）→ 网卡驱动。这条路径中，应用程序可以直接访问操作系统内核提供的网络 API。
>
> WebAssembly 程序运行在一个受宿主环境（Host）严格控制的沙箱中。WASM 模块不能直接发起系统调用——所有与外部世界的交互都必须通过宿主导出的"导入函数"（Import Functions）进行。在浏览器环境中，宿主是 JavaScript 引擎，它只导出了 WebGL、Fetch API、WebSocket 等有限的 Web 标准接口，**而没有暴露 POSIX `socket()` / `connect()` 等系统调用**。
>
> **结论**：WASM 沙箱根本没有通向内核网络栈的"门"。即使微信想开放原生 Socket，也需要在 WASM 导入函数层注册对应的 Native 回调——而这样做会完全打破沙箱安全边界，因此标准 WebAssembly 规范明确不提供此能力。

### 9.2 根因层次二：Emscripten 的 Socket 模拟层及其局限

Emscripten 为了让大量依赖 POSIX Socket API 的 C/C++ 代码能编译到 WebAssembly，提供了一个 Socket 兼容层（`emscripten/src/library_network.js`）。这一层将 POSIX socket 调用模拟转换为 WebSocket，但它的模拟是**不完整的**：

| Socket 类型 | POSIX 原语 | Emscripten 模拟 | 实际可用性 |
|-------------|-----------|-----------------|-----------|
| TCP Stream | `socket(AF_INET, SOCK_STREAM)` | → WebSocket（有状态，可靠有序） | ✅ 有限支持（见注意事项） |
| UDP Datagram | `socket(AF_INET, SOCK_DGRAM)` | 无对应 Web API，模拟失败 | ❌ 运行时抛出 ENOSYS |
| Unix Domain | `socket(AF_UNIX, ...)` | 无对应 Web API | ❌ 完全不支持 |
| Raw Socket | `socket(AF_INET, SOCK_RAW)` | 浏览器安全策略明确禁止 | ❌ 不支持 |
| Multicast | `setsockopt IP_ADD_MEMBERSHIP` | WebSocket 无组播概念 | ❌ 不支持 |

> ❌ **TCP 模拟的关键限制**：Emscripten 将 TCP socket 映射为 WebSocket，但 TCP 是字节流（Stream）协议，WebSocket 是消息（Message）协议，这个映射有根本差异。
>
> 更重要的是：**Unity 的 `System.Net.Sockets` 并不直接使用 Emscripten 的 socket 模拟层**。Unity 在 IL2CPP 时将 `System.Net.Sockets` 的 C# 实现编译为 C++，这套 C++ 代码依赖于真正的 POSIX socket 系统调用，而非 Emscripten 的 JS 桥接层。因此在 Unity WebGL 中，`System.Net.Sockets` 的任何 API 都直接失败，不经过 Emscripten 的 WebSocket 模拟。

### 9.3 根因层次三：微信小游戏的网络安全策略

即使绕过了前两层限制，微信的 Native 拦截层还有额外的网络安全约束：

| 安全策略 | 技术说明与原因 |
|----------|---------------|
| 仅支持 wss:// | 微信拦截所有明文 `ws://` WebSocket 连接请求，防止中间人攻击（MITM）窃取游戏通信内容。对在公共 WiFi 下的玩家提供基础安全保障 |
| 最多 5 个并发 WebSocket | 移动端每个 WebSocket 连接维护在 iOS WKWebView / Android WebView 内，底层占用 TCP 连接 + TLS 会话 + 内存缓冲区；限制并发数防止小游戏耗尽设备网络资源，影响微信自身消息收发 |
| 域名必须在 socket 合法域名白名单 | 与 HTTP request 白名单独立管理；强制要求域名 ICP 备案，保证 WebSocket 服务器可溯源，防止小游戏接入境外违规服务器或匿名代理 |
| 端口需显式声明 | 不能动态连接任意端口，端口号需在域名白名单配置时一并声明 |

### 9.4 WebSocket 与原生 Socket 的核心差异对照

| 维度 | 原生 TCP Socket | WebSocket（wss://） |
|------|----------------|---------------------|
| 传输协议 | TCP（SOCK_STREAM）— 字节流，无消息边界 | TCP + TLS + WebSocket 帧协议（三层叠加） |
| 连接建立 | `connect()` 完成即可通信（1 RTT） | TCP 握手 + TLS 握手 + HTTP Upgrade = 约 2–3 RTT |
| 消息边界 | 无边界，需自定义帧头（长度前缀/分隔符） | 原生消息边界，每帧独立完整，无需粘包处理 |
| UDP 支持 | ✅ SOCK_DGRAM，无连接，无序，低延迟 | ❌ 不支持 UDP，所有通信必须经过 TCP |
| 延迟特性 | 纯 TCP 延迟（通常 10–50ms） | TCP + TLS 额外开销（通常 +5–15ms per RTT） |
| 后台保活 | OS 级别保活，App 后台仍可收发 | 依赖浏览器/微信生命周期，后台可能被挂起 |
| 断线感知 | 内核 TCP keepalive 可快速感知（秒级） | 依赖应用层 Ping/Pong 心跳（通常 30s 检测周期） |
| 连接数限制 | 受 OS 文件描述符限制（通常 >1000） | 微信限制最多 5 个并发 WebSocket |

### 9.5 UDP 帧同步的特殊困境与解决路径

> ⚠️ **UDP 不可用对实时对战游戏的影响**
>
> 许多实时 PVP 游戏使用 UDP + KCP（快速可靠传输协议）的组合——KCP 在 UDP 之上实现可靠有序传输，同时比 TCP 具有更低的重传延迟和更激进的拥塞控制策略。这一技术栈在 WebGL/微信小游戏中完全失效：WebSocket 底层是 TCP，已经具备可靠传输，但不具备 KCP 的低延迟特性，且无法关闭 TCP 的 Nagle 算法（会引入额外延迟）。
>
> **可行的替代路径：**
>
> 1. **帧同步降频**：将同步频率从 20fps 降至 10fps，每帧数据包变大但频率降低，WebSocket 延迟影响被摊薄
> 2. **状态同步替代帧同步**：服务器维护权威状态，客户端只上传操作（操作频率低），对网络延迟敏感度更低
> 3. **减少 Nagle 延迟影响**：WebSocket 协议级别无法关闭 TCP Nagle，但可以通过确保每条消息数据量足以触发立即发送，减少 Nagle 延迟影响

---

## 十、限制速查与根因总结

| 限制类型 | 具体限制 | 技术根因 | 最优应对策略 |
|----------|----------|----------|-------------|
| 包体大小 | 主包 4MB / 分包 20MB | 冷启动时间模型 + WASM 编译内存乘数效应 | 资源全部 CDN 化；代码极致裁剪 |
| 多线程 | 无真实多线程；Job System 单线程 | WASM GC 无法扫描多线程栈 | 算法降级；分帧处理替代并行 |
| Burst 编译器 | 完全不可用 | LLVM 无 WASM SIMD 代码生成后端 | `#if !UNITY_WEBGL` 条件分支；预计算替代 |
| async/await | `Task.Delay`/`Run` 等 API 崩溃 | WebGL 无 ThreadPool；JS Event Loop 单线程 | 使用 UniTask 全量替换 |
| 原生 Socket | `System.Net.Sockets` 全部失效；UDP 完全不支持 | WASM 沙箱无系统调用权限；Unity IL2CPP 不经 Emscripten 模拟层 | 全面迁移 WebSocket (wss://)；UDP 帧同步降频或改状态同步 |
| 内存 | iOS 2GB 设备总量约 900MB–1.2GB | 共享进程 + WASM 内存只增不减 | ASTC 纹理；及时 WXUnload；控制峰值 |
| 并发请求 | 最多 10 个 HTTP / 5 个 WebSocket 并发 | HTTP/1.1 协议限制 + iOS NSURLSession + 平台安全策略 | 请求队列管理；多路复用单条 WebSocket |
| 域名访问 | 必须在白名单，HTTPS/WSS + ICP 备案 | 微信 Native 拦截层安全校验 | 提前备案；socket/request 两个白名单独立配置 |
| 文件系统 | 200MB 本地缓存，无直接磁盘 API | iOS 沙箱策略 + Emscripten MemFS 模型 | WX 文件系统 API；缓存失效重下载兜底 |
| iOS 内购 | 不能在小游戏内直接支付 | Apple IAP 政策 | 跳转 H5 页面或客服消息支付 |
| GPU Instancing | iOS DrawMeshInstanced ≤ 32 矩阵 | Metal uniform buffer 大小限制 | 拆分大批次；每次 ≤32 矩阵 |

---

> **技术洞察：限制即设计**
>
> 微信小游戏的每一项技术限制，都根植于 WebAssembly 规范、iOS/Android 系统安全模型、苹果生态系统商业政策这三个层次的约束体系中。这些限制不是微信团队的工程失误，而是在"即点即玩用户体验 × 移动设备资源约束 × 平台安全合规"三维目标下的主动设计取舍。理解根因，才能超越表面规避，在架构层做出正确决策。
