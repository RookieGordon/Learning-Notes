---
tags:
  - ET
---
# aCTORId和Address结构体
`Address`和`ActorId`结构体如下
```CSharp
public struct Address
{
	[MemoryPackOrder(0)]
	public int Process;
	[MemoryPackOrder(1)]
	public int Fiber;
	// 其他....
}

public struct ActorId
{
	[MemoryPackOrder(0)]
	public Address Address;
	[MemoryPackOrder(1)]
	public long InstanceId;
	// 其他...
}
```
在客户端中，`ActorId`用于记录消息的发送来源和目标。`Address`用于标记`Fiber`的地址。在客户端收发的消息，会被包装成`MessageInfo`结构体，消息内容放在`MessageObject`当中
```CSharp
public struct MessageInfo
{
    public ActorId ActorId;
    public MessageObject MessageObject;
}
```
# 客户端收发消息
`ProcessInnerSender`是用于网络消息收发的组件，挂在`Root Scene`节点上
```CSharp
public int RpcId;
public readonly Dictionary<int, MessageSenderStruct> requestCallback = new();
public readonly List<MessageInfo> list = new();
```
`RpcId`用于标记发送的`Actor`的`RpcId`，该值是自增的，确保每个`Actor`的`RpcId`不重复。
`ClientSenderComponent`是客户端使用的网络消息发送组件，挂在`Root Scene`节点上。是对`ProcessInnerSender`发送网络消息功能的封装。
```CSharp
[ComponentOf(typeof(Scene))]
public class ClientSenderComponent: Entity, IAwake, IDestroy
{
    public int fiberId;
    public ActorId netClientActorId;
}
```
该组件封装了`Call`和`Send`两个发送协议的方法。
## Call和Send发送Actor消息
```CSharp
public static async ETTask<IResponse> Call(
                this ProcessInnerSender self,
                ActorId actorId,
                IRequest request,
                bool needException = true)
{
    int rpcId = self.GetRpcId();
    request.RpcId = rpcId;
    Fiber fiber = self.Fiber();
    // 做一些检查
    Type requestType = request.GetType();
    IResponse response;
    if (!self.SendInner(actorId, (MessageObject)request))  // 纤程不存在
    {
        response = MessageHelper.CreateResponse(requestType, 
                                                rpcId, 
                                                ErrorCore.ERR_NotFoundActor);
        return response;
    }
            
    MessageSenderStruct messageSenderStruct = new(actorId, 
                                                  requestType, 
                                                  needException);
    self.requestCallback.Add(rpcId, messageSenderStruct);
    async ETTask Timeout()
    {
        .....
    }
            
    Timeout().Coroutine();
    response = await messageSenderStruct.Wait();
    return response;
}
```
`Call`用于有回包的`Actor`消息的发送，并且只能发往同一个进程。
`SendInner`方法，会使用`MessageQueue`单例对象，将需要发送的消息，添加到队列中去。
创建一个`MessageSenderStruct`结构体，放到`requestCallback`字典中，用于等待回包，
`Send`方法因为不需要等待回包，相对简单，直接调用`SendInner`方法，将需要发送的内容添加到发送队列中
`MessageQueue`中的消息是根据`Fiber`的Id进行分类存储的。`ProcessInnerSender.Update`方法中，会获取当前`Root Scene Fiber`中，是否有待发送的消息队列，如果有则遍历每个消息，调用`HandleMessage`方法
```CSharp
private static void HandleMessage(this ProcessInnerSender self, 
                                   Fiber fiber, 
                                   in MessageInfo messageInfo)  
{  
    if (messageInfo.MessageObject is IResponse response)  
    {        
        self.HandleIActorResponse(response);  
        return;  
    }  
    
    ActorId actorId = messageInfo.ActorId;  
    MessageObject message = messageInfo.MessageObject;  
  
    MailBoxComponent mailBoxComponent 
                                = self.Fiber().Mailboxes.Get(actorId.InstanceId);  
    if (mailBoxComponent == null)  
    {        
        // 非法情形处理
    }    
    mailBoxComponent.Add(actorId.Address, message);  
}
```

^3a23da

`HandleMessage`方法中，如果一个消息是回包类型，那么会使用`HandleIActorResponse`另外处理，请求的协议，会获取到`Root Scene Fiber`的邮箱组件`MailBoxComponent`，通过其将协议发送出去。
`HandleIActorResponse`方法中，会根据`RpcId`来获取对应请求协议创建的`MessageSenderStruct`对象，设置其Task完成。

> [!important]
> 1、客户端是通过`NetClient Fiber`来发送网络消息的
> 2、`ActorId`用于记录一个消息的具体的发送来源（`Actor.Adress`记录的就是`Fiber`的地址）。对客户端而言，就是`NetClient Fiber`
> 3、发送的协议消息在`MessageQueue`中，是按照发送方`Fiber`来分组存放的
> 4、`MessageQueue`队列中的`MessageInfo`，记录了消息的来源（`Fiber`）和`Actor`消息的`InstanceId`，以及具体的消息体
