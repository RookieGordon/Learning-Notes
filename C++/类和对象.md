---
tags:
  - Cpp
---

## 类的定义
![[2024-03-27-17-27-43.png]]

函数的实现可以直接写在类声明中。这样定义的函数会直接变成内联函数（**inline funtion**）。也可以只包含函数的声明，具体实现在类定义之外，使用作用域声明符号“==**::**==”进行定义。

```C++
class Car
{
public:
    string Color;
    string Engine;
    float GasTank;
    unsigned int Wheel;
    // 加油
    void FillTank(float liter);
};

inline void Car::FillTank(float liter)
{
    GasTank += liter;
}
```

选择在类内部还是类外部定义方法取决于具体的情况和个人偏好。一般来说，如果方法的实现比较简单且经常被调用，可以考虑在类内部定义以提高性能。而对于复杂的方法实现或者需要在多个地方调用的方法，将其定义在类外部可以提高代码的可读性和可维护性。

### 构造函数和析构函数

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

> 构造函数在对象被声明的时候就会被调用，即使没有对该对象做任何操作！

类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

> ==析构函数是虚函数。声明为虚函数，可以确保在删除基类指针指向的派生类对象时，先调用派生类的析构函数，然后再调用基类的析构函数，从而正确地释放资源，避免内存泄漏。==

在C++中，通常不需要手动调用类的析构函数。析构函数是在对象销毁时自动调用的，用于清理对象所占用的资源。当对象超出其作用域或者被显式删除时，析构函数会被自动调用。在某些特殊情况下，可以手动调用析构函数。

1. 使用 `delete` 运算符：  
    如果对象是通过  
    `new` 运算符动态分配的，你可以使用 `delete` 运算符来销毁对象并调用其析构函数。
    
    ```C++
    MyClass* obj = new MyClass();
    // 使用对象
    delete obj;  // 手动调用析构函数并释放内存
    ```
    
2. 显式调用析构函数：  
    你可以通过在对象上显式调用析构函数来销毁对象。但是，这种方式只会调用析构函数，不会释放对象所占用的内存。  
    **需要注意的是，显式调用析构函数后，对象仍然存在，只是其资源被清理了。这种方式通常在特殊情况下使用，如在内存池或自定义内存管理中。**
3. 使用 `placement new` 和 `placement delete`：  
    通过使用  
    `placement new` 在已分配的内存上构造对象，并使用 `placement delete` 在同一内存上调用析构函数，可以手动控制对象的构造和析构。
    
    ```C++
    char* buffer = new char[sizeof(MyClass)];
    MyClass* obj = new (buffer) MyClass();  // 在 buffer 上构造对象
    // 使用对象
    obj->~MyClass();  // 在 buffer 上调用析构函数
    delete[] buffer;  // 释放内存
    ```
    
    这种方式通常用于在已分配的原始内存上构造和析构对象，如在内存池或自定义内存管理中。
    
    > 在示例中，`buffer` 指针被声明为 `char*` 类型，是为了分配原始内存，而不是特定类型的内存。使用 `char*` 的原因如下：
    > 
    > 1. `char` 是 C++ 中最基本的数据类型之一，占用 1 个字节的内存。
    > 2. `char*` 指针可以指向内存中的任意位置，不限于特定类型的对象。
    > 3. 通过将指针声明为 `char*`，我们可以将其视为一块原始内存，而不关心内存中存储的具体数据类型。
    > 4. 在使用 `placement new` 时，我们只关心内存的大小和位置，而不关心内存的类型。
    

需要注意的是，手动调用析构函数时要格外小心，确保在合适的时机调用，并且不要在已经销毁的对象上重复调用析构函数，否则可能会导致未定义的行为。在大多数情况下，让编译器自动处理对象的析构是最佳实践。只有在特殊情况下，如内存池、自定义内存管理或某些高级技术中，才需要手动调用析构函数。

### 拷贝构造函数

**拷贝构造函数**是一种特殊的构造函 数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。==**如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数**==。拷贝构造函数的最常见形式如下：

```C++
// obj 是一个对象引用，该对象是用于初始化另一个对象的。
classname (const classname &obj) {
   // 构造函数的主体
}
```

## this指针

在 C++ 中，**this** 指针是一个特殊的指针，它指向当前对象的实例。在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。==**this是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象**==。

当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。友元函数没有 **this** 指针，因为友元不是类的成员，只有成员函数才有 **this** 指针。

## 友元函数

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**，如下所示：

```C++
class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
```

声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：

```C++
friend class ClassTwo;
```

## 继承

```C++
// 基类
class Animal {
    // eat() 函数
    // sleep() 函数
};

//派生类
class Dog : public Animal {
    // bark() 函数
};
```

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

### 构造函数继承

构造函数继承和类继承的写法类似：

```C++
子类::子类(全部参数表):父类1(父类1参数表),父类2(父类2参数表)
      ...对象成员1(对象成员1参数表),对象成员2(对象成员2参数表)
// 对象成员表示子类新增的对象成员（某些外部类的对象作为子类成员）。
```

> [!important]  
> 继承中，子类的构造函数在所有父类构造函数调用完毕后，最后再调用。而析构函数在所有父类的析构函数调用前，最先被调用。  

### 函数的覆写

> [!important]  
> 在C++中，如果不使用virtual关键字，函数的覆写（overriding）仍然可以进行。在这种情况下，派生类的函数会隐藏基类的同名函数，但是它们并不构成多态。  

被覆写的函数，必须要使用==**virtual**==关键字！

## 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字 **operator** 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

下面是可重载的运算符列表：

|         |                                                                                                                          |
| ------- | ------------------------------------------------------------------------------------------------------------------------ |
| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                                                                                              |
| 关系运算符   | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于)                                                                          |
| 逻辑运算符   | \|(逻辑或)，&&(逻辑与)，!(逻辑非)                                                                                                   |
| 单目运算符   | + (正)，-(负)，*(指针)，&(取地址)                                                                                                  |
| 自增自减运算符 | ++(自增)，--(自减)                                                                                                            |
| 位运算符    | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)                                                                         |
| 赋值运算符   | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=                                                                          |
| 空间申请与释放 | new, delete, new[ ] , delete[]                                                                                           |
| 其他运算符   | ()（函数调用），[->（成员访问）](https://www.runoob.com/cplusplus/class-member-access-operator-overloading.html)，**,**（逗号），**[]**(下标) |

下面是不可重载的运算符列表：
- **.**：成员访问运算符
- **.\*, ->\***：成员指针访问运算符
- **::**：域运算符
- sizeof：长度运算符
- **?:**：条件运算符
- **#**： 预处理符号

> 类成员访问运算符（ -> ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予"指针"行为。运算符 -> 必须是一个成员函数。如果使用了 -> 运算符，返回类型必须是指针或者是类的对象。

>这对于某些操作符重载非常重要，例如比较操作符（==、<、>等）、下标操作符（[]）等。这些操作符通常只是用于访问对象的数据，而不应该修改对象