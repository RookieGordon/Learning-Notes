---
tags:
  - 图形学
  - 软光栅
---
# 裁剪

## 点与直线，点与平面的位置关系

### 直线方程的向量理解

将直线方程$y = kx + b$转换成$\vec{n} * \vec{p} = d$，其中$\vec{p} = (x, y)$。$d$为常数，等于原点到直线的距离。$\vec{n}$向量为单位向量，垂直于直线，指向直线。
![[（图解66）直线的向量理解.png|356]]

这样，可以将直线方程理解成，p点是所有满足向$\vec{n}$投影长度为d的点的集合。

### 直线方程的距离理解

直线表达式中的d发生变化的时候，意味着直线沿着法线$\vec{n}$滑动

### 点与直线的距离关系

空间中任一点q，带入到直线方程，得到的结果都是q在$\vec{n}$上的投影。当$\vec{n} * \vec{q} - d > 0$，表示q在法线一侧，即正面，反正在背面。
![[（图解67）点与直线的距离关系.png|372]]

### 平面方程

空间中一平面，使用法线方式表达如下：$ax + by + cz = d$。同样可以令$\vec{n} = [a, b, c]$，则可以写成$\vec{n} * \vec{p} = d$的形式。 
![[（图解68）空间中平面的向量理解.png|347]]
所以，一个平面表示，p点是所有满足向$\vec{n}$投影长度为d的点的集合。

因此，类比于直线方程，有当$\vec{n} * \vec{q} - d > 0$，表示q在平面法线一侧，即正面，反正在背面。

## 多边形剪裁算法——Sutherland-Hodgman算法（逐边裁剪法）

SH算法采用了分割处理，逐边裁剪的方法。

### 二维空间中的Sutherland-Hodgman算法

二维空间中，算法思想如下：
- 一次用窗口的一条边裁剪多边形，循环多次
- 每次，构造一个空的点数组DST；原数组为SRC
- 每次，所有顶点从0号开始，作为S点，S后面的点为P点，依次进行测试，结果输出点到DST，剪裁原则如下图
- SRC=DST
![[（图解69）逐边裁剪算法两个顶点的不同测试情况.png]]

举例如下：
![[（图解70）考察上边界，裁剪三角形.png|529]]
![[（图解71）考察右边界裁剪四边形.png|530]]

#### 多边形重建三角形

上方的例子中，三角形经过两条边界的裁剪完成后，输出了一个四边形，这时候，就需要进行三角形重建，将四边形拆分成两个三角形。拆分思路如下：`永远以数组的第一个顶点为起始点，递进构建三角形`
![[（图解72）四边形拆分成三角形.png|348]]
这样，1-1'-2’'-0这个四边形就被拆分成了1-1‘-2‘’和1-2‘’-0这两个三角形。

#### 顶点属性插值
 
当两个点位于平面内外两侧，我们需要对其进行插值，从而得到相交点的位置/颜色/u等属性。
![[（图解73）边界交点属性插值.png|367]]
插值计算流程如下，注意，这里的距离都是有方向的！
1. 得到边界线的方程表达式
2. 将p/s点带入求出与边界的距离
3. 选择任何一条距离作为系数，执行线性插值
$$\begin{align}
weight & = \frac{l_{s}}{l_{s}-l_{p} } = \frac{d_{s}}{d_{s}-d_{p} } \\
I_{position} &= P_{position}\cdot weight + S_{position}\cdot (1-weight)\\
I_{color} &= P_{color}\cdot weight + S_{color}\cdot (1-weight)\\
I_{uv} &= P_{uv}\cdot weight + S_{uv}\cdot (1-weight)\\
\end{align}$$

### 三维空间中的Sutherland-Hodgman算法

在三维情况下，剪裁边变成了剪裁平面；我们选择在NDC构成的-1到1盒体内进行剪裁，但是必须保证：
- 顶点在摄像机前方
- 顶点z值不为0（即不与摄像机重合） 
因为z=0代表与摄像机重合，z<0代表在摄像机后方，这两种情况可以直接排除掉。

根据上述条件以及NDC下点坐标必须为-1到1内，可使用剪裁空间坐标对内外进行判定，判定条件如下：
![[（图解74）NDC空间判定条件.png|687]]

将判定方程补上xyz坐标后，可以发现，判定条件其实是一个四维空间平面，并且距离d = 0。

### 代码设计

```Cpp
/// <summary>
/// Sutherland-Hodgman剪裁
/// </summary>
static void sutherlandHodgman(const uint32_t& drawMode, const std::vector<VsOutput>& primitive, std::vector<VsOutput>& outputs);
```
直线和三角形的裁剪流程是有所不同的。

由[[#三维空间中的Sutherland-Hodgman算法 | 判定条件]]，先构建出NDC空间裁剪平面：
```Cpp
std::vector<math::vec4f> clipPlanes = {
        //judge w > 0
        math::vec4f(0.0f, 0.0f, 0.0f, 1.0f),
        //near
        math::vec4f(0.0f, 0.0f, 1.0f, 1.0f),
        //far
        math::vec4f(0.0f, 0.0f, -1.0f, 1.0f),
        //left
        math::vec4f(1.0f, 0.0f, 0.0f, 1.0f),
        //right
        math::vec4f(-1.0f, 0.0f, 0.0f, 1.0f),
        //top
        math::vec4f(0.0f, -1.0f, 0.0f, 1.0f),
        //bottom
        math::vec4f(0.0f, 1.0f, 0.0f, 1.0f)
    };
```


# 透视修正