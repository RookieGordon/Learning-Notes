---
tags:
  - 图形学
  - 软光栅
---
# 渲染阶段总结

1、初始化模型和摄像机
- 相机会初始化到原点，并且看向z轴负方向
- 模型会初始化一个模型坐标系，该坐标系和世界坐标系重合。并且会初始化顶点的位置（相对于模型坐标系）和属性

2、模型和相机的运动会产生两个矩阵——模型的modelMatrix和相机的modelMatrix。

3、使用相机的viewMatrix（相机modelMatrix的逆矩阵）同时对相机和模型进行变换。在此变换过程中，模型和相机一直保持相对静止。此时，模型被变换到了摄像机坐标系中，而摄像机则变换到了初始状态。

4、通过投影变换矩阵（），将模型变换到裁剪坐标系中。在剪裁坐标系中，对模型进行剪裁工作。剪裁工作完成后，进行透视除法，将坐标变换到NDC空间中（-1到1）。

5、最后，通过屏幕空间变换矩阵（screenMatrix），将模型的顶点变换到屏幕空间的像素位置。

6、使用顶点的屏幕坐标，对三角形进行光栅化处理
- 得到所有像素，已经像素的属性插值结果
- 根据每个像素数据，对应渲染

## 架构梳理

1、在进行屏幕光栅化之前，所有的操作都是<font color="#ff0000">针对模型顶点</font>
2、每一步的操作都是在<font color="#ffff00">前一步得到的顶点数据</font>基础上进行
3、可以把对<font color="#00b050">顶点的操作过程(mvp)</font>设计成一个<font color="#00b050">单独的模块</font>，把所有<font color="#92d050">对像素的操作过程</font>设计成一个<font color="#92d050">单独的模块</font>
4、处理每个顶点的程序我们称为<font color="#c00000">VertexShader（顶点着色器）</font>，处理每个像素的过程称<font color="#ffff00">PixelShader（像素着色器）</font>，这两个着色器程序可以设计为*可扩展/可编程*的过程，而*中间（剪裁/透视除法/背面剔除/屏幕空间映射/光栅化）*过程我们固化掉