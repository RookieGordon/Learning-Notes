---
tags:
  - 图形学
  - 软光栅
---
# Windows窗体

## Windows API

windows API一般采用句柄（Handle）来进行资源操作。
- 句柄（Handle）是一个是用来标识对象或者项目的标识符，可以用来描述窗体、文件等
- 句柄通常可以是一个整数或者一个指针类型
- 句柄所指代的资源通常不能直接访问
- 句柄通常会作为AP的参数，通过AP函数来改变句柄指代资源的状态

-## Windows入口函数

Windowsi窗口程序需要满足如下特点：
- 使用wWinMain作为程序入口点，而不是main函数
- 使用#pragma comment的linker选项，选择入口点，并且决定是否启用console
- 选项
	- entry（mainCRTStartup/wWinMainCRTStartup），用于控制人口函数是main还是wWinMain。
	- subsystem:console/windows，console表示，创建一个窗口，并且可以使用命令

```Cpp
#include <Windows.h>

#pragma comment(linker, "/subsystem:console /entry:wWinMainCRTStartup" )

int APIENTRY wWinMain(
	_In_ HINSTANCE hInstance,		//本应用程序实例句柄，唯一指代当前程序
	_In_opt_ HINSTANCE hPrevInstance,	//本程序前一个实例，一般是null
	_In_ LPWSTR    lpCmdLine,		//应用程序运行参数
	_In_ int       nCmdShow)		//窗口如何显示（最大化、最小化、隐藏），不需理会
{
	return 0;
}
```

## Windows窗体

### 创建窗口并显示

```cardlink
url: https://github1s.com/RookieGordon/CustomSoftRenderer/blob/main/Codes01-Windows/main.cpp
title: "GitHub1s"
host: github1s.com
favicon: https://github1s.com/favicon-light.svg
```
#### 指定窗口类型，注册窗口

WNDCLASSEXW是窗体类型的模板，创建一个对象，设置窗口大小，窗口重绘事件，图标，背景色，标题等等属性。确定完成窗体类型后，使用`RegistClassExW`函数注册窗体类型。

#### 函数创建窗口

```Cpp
mHwnd = CreateWindowW( mWindowClassName,
        (LPCWSTR)"GraphicLearning", //窗体标题
        dwStyle,
        500,//x位置，相对左上角
        500,//y位置，相对左上角
        windowRect.right - windowRect.left,
        windowRect.bottom - windowRect.top,
        nullptr,//父窗体
        nullptr,//菜单栏
        hInstance,//程序实例，由wWinMain入口函数传入
        nullptr);//额外参数
```
该函数返回一个窗体的句柄。windowRect是控制窗体大小的结构体。

#### 监听窗口消息

```Cpp
MSG msg;
// 捕获窗体消息
if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
{
	// 构建消息体
	TranslateMessage(&msg);
	// 分发消息
	DispatchMessage(&msg);
}
```
窗体程序，需要一个死循环来不断的渲染窗体，不然是没有办法显示的。这里是在While中来窗体消息的。

## WindowsGDI绘图环境

GDl是图形设备接口(GDl:Graphics Device Interface)的缩写，是Windows的子系统，它负责在视
讯显示器和打印机上显示图形

HDC（Handle of Device Context）：即GDI体系中的设备描述上下文；
- 在Windows操作系统中，显示资源属于所有APP公用资源，公用就需要虚拟化成多个虚拟设备
- 每个窗体运行在其虚拟显示设备上，其窗体句柄就对应了一个正在使用的设备DC
- 每个HDC句柄背后都记录了当前窗体显示对应的内存/尺寸等信息
如果想在窗口绘制物体，就需要想HDC所指代的设备内存输出颜色数据即可

### HDC绘图原理

^6b511f

通过双缓冲机制进行绘图
1. 获取当前窗口HDC
2. 创建与其兼容的HDC2
3. 将内容绘制到HDC2的内存中
4. 每帧都从HDC2向HDC拷贝数据

### HDC的获取和创建

通过`GetDC`获取当前窗口对应的HDC虚拟绘图设备。获取到HDC后，再通过`CreateCompatibleDC`创建一个与hDC相兼容的hDC2，那么就可以在hDC2上绘制数据，拷贝到hDC进行显示。

```Cpp
//获取当前窗体HD©
hDC = GetDC(hwnd);
//创建与当前窗体兼容的HDC2(内存格式/分辨率等)
hDC2 = CreateCompatibleDC(hDC);
// 把hDC2对应内存的数据拷贝到hDC
BitBlt(hDC, xdst, ydst, width, height, hDC2, xsrc, ysrc, SRCCOPY);
```

### HDC与绘图

位图对象句柄是HBITMAP，每个HDC都可以使用自己的虚拟资源，分配多张位图对象，如下图
![[（图解1）HDC中的位图对象.png|228]]

通过`SelectObject(hDC, bmp2)`函数，可以选中激位图。`对本HDC的数据操作，都是在操作被激活的位图对应的内存区域`。

#### HBITMAP位图的创建

使用`CreateDIBSection`在HDC上为位图开辟空间，这块内存的指针会给到buffer。指定bmp的宽高，像素大小，像素压缩方式等等。
![[（图解2）创建位图.png|612]]

在Window窗体中，颜色通道的排布顺序是B、G、R、A。

函数`CreateDIBSection`中，对mCanvasBuffer进行了`(void**)`操作，因为需要修改这个指针本身，使其指向一个新位置。
```Cpp
HBITMAP CreateDIBSection(
  [in]  HDC              hdc,
  [in]  const BITMAPINFO *pbmi,
  [in]  UINT             usage,
  [out] VOID             **ppvBits,
  [in]  HANDLE           hSection,
  [in]  DWORD            offset
)
```
第四个参数的类型是`void** ppvBits`，[[数据结构#^7148fa|它期望接收一个指向指针的指针]]。函数将使用这个指针来返回一个指向DIB位图像素数据的指针。换句话说，<font color="#00b050">函数需要一个指针来存储它创建的另一个指针</font>。
>[!NOTICE]
>现在，让我们看看mCanvasBuffer。它被定义为一个`void*`类型的变量，这意味着它是一个指针。如果我们直接将mCanvasBuffer传递给函数，我们只是传递了一个指针的值，函数无法修改mCanvasBuffer本身。但是，通过传递&mCanvasBuffer，它是一个指向void\*类型指针的指针。通过传递&mCanvasBuffer，我们给了函数一个可以用来存储新创建的指针的位置。函数可以修改mCanvasBuffer的值，使其指向新分配的DIB位图像素数据。
# 绘制直线

## Brensenham直线绘制算法

## 直线绘制

mCanvasBuffer被定义成了void*，表示一个指针，那么指向指针的指针应该是对mCanvasBuffer进行取指针操作才对呀？为什么会写成(void**)