---
tags:
  - 图形学
  - 软光栅
---
# Windows窗体

## Windows API

windows API一般采用句柄（Handle）来进行资源操作。
- 句柄（Handle）是一个是用来标识对象或者项目的标识符，可以用来描述窗体、文件等
- 句柄通常可以是一个整数或者一个指针类型
- 句柄所指代的资源通常不能直接访问
- 句柄通常会作为AP的参数，通过AP函数来改变句柄指代资源的状态

-## Windows入口函数

Windowsi窗口程序需要满足如下特点：
- 使用wWinMain作为程序入口点，而不是main函数
- 使用#pragma comment的linker选项，选择入口点，并且决定是否启用console
- 选项
	- entry（mainCRTStartup/wWinMainCRTStartup），用于控制人口函数是main还是wWinMain。
	- subsystem:console/windows，console表示，创建一个窗口，并且可以使用命令

```Cpp
#include <Windows.h>

#pragma comment(linker, "/subsystem:console /entry:wWinMainCRTStartup" )

int APIENTRY wWinMain(
	_In_ HINSTANCE hInstance,		//本应用程序实例句柄，唯一指代当前程序
	_In_opt_ HINSTANCE hPrevInstance,	//本程序前一个实例，一般是null
	_In_ LPWSTR    lpCmdLine,		//应用程序运行参数
	_In_ int       nCmdShow)		//窗口如何显示（最大化、最小化、隐藏），不需理会
{
	return 0;
}
```

## Windows窗体

### 创建窗口并显示

```cardlink
url: https://github1s.com/RookieGordon/CustomSoftRenderer/blob/main/Codes01-Windows/main.cpp
title: "GitHub1s"
host: github1s.com
favicon: https://github1s.com/favicon-light.svg
```
#### 指定窗口类型，注册窗口

WNDCLASSEXW是窗体类型的模板，创建一个对象，设置窗口大小，窗口重绘事件，图标，背景色，标题等等属性。确定完成窗体类型后，使用`RegistClassExW`函数注册窗体类型。

#### 函数创建窗口

```Cpp
mHwnd = CreateWindowW( mWindowClassName,
        (LPCWSTR)"GraphicLearning", //窗体标题
        dwStyle,
        500,//x位置，相对左上角
        500,//y位置，相对左上角
        windowRect.right - windowRect.left,
        windowRect.bottom - windowRect.top,
        nullptr,//父窗体
        nullptr,//菜单栏
        hInstance,//程序实例，由wWinMain入口函数传入
        nullptr);//额外参数
```
该函数返回一个窗体的句柄。windowRect是控制窗体大小的结构体。

#### 监听窗口消息

```Cpp
MSG msg;
// 捕获窗体消息
if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
{
	// 构建消息体
	TranslateMessage(&msg);
	// 分发消息
	DispatchMessage(&msg);
}
```
窗体程序，需要一个死循环来不断的渲染窗体，不然是没有办法显示的。这里是在While中来窗体消息的。

## WindowsGDI绘图环境

GDl是图形设备接口(GDl:Graphics Device Interface)的缩写，是Windows的子系统，它负责在视
讯显示器和打印机上显示图形

HDC（Handle of Device Context）：即GDI体系中的设备描述上下文；
- 在Windows操作系统中，显示资源属于所有APP公用资源，公用就需要虚拟化成多个虚拟设备
- 每个窗体运行在其虚拟显示设备上，其窗体句柄就对应了一个正在使用的设备DC
- 每个HDC句柄背后都记录了当前窗体显示对应的内存/尺寸等信息
如果想在窗口绘制物体，就需要想HDC所指代的设备内存输出颜色数据即可

### HDC绘图原理

^6b511f

通过双缓冲机制进行绘图
1. 获取当前窗口HDC
2. 创建与其兼容的HDC2
3. 将内容绘制到HDC2的内存中
4. 每帧都从HDC2向HDC拷贝数据

### HDC的获取和创建

通过`GetDC`获取当前窗口对应的HDC虚拟绘图设备。获取到HDC后，再通过`CreateCompatibleDC`创建一个与hDC相兼容的hDC2，那么就可以在hDC2上绘制数据，拷贝到hDC进行显示。

```Cpp
//获取当前窗体HD©
hDC = GetDC(hwnd);
//创建与当前窗体兼容的HDC2(内存格式/分辨率等)
hDC2 = CreateCompatibleDC(hDC);
// 把hDC2对应内存的数据拷贝到hDC
BitBlt(hDC, xdst, ydst, width, height, hDC2, xsrc, ysrc, SRCCOPY);
```

### HDC与绘图

位图对象句柄是HBITMAP，每个HDC都可以使用自己的虚拟资源，分配多张位图对象，如下图
![[（图解1）HDC中的位图对象.png|228]]

通过`SelectObject(hDC, bmp2)`函数，可以选中激位图。`对本HDC的数据操作，都是在操作被激活的位图对应的内存区域`。

#### HBITMAP位图的创建

使用`CreateDIBSection`在HDC上为位图开辟空间，这块内存的指针会给到buffer。指定bmp的宽高，像素大小，像素压缩方式等等。
![[（图解2）创建位图.png|612]]

在Window窗体中，颜色通道的排布顺序是B、G、R、A。

函数`CreateDIBSection`中，对mCanvasBuffer进行了`(void**)`操作，因为需要修改这个指针本身，使其指向一个新位置。
```Cpp
HBITMAP CreateDIBSection(
  [in]  HDC              hdc,
  [in]  const BITMAPINFO *pbmi,
  [in]  UINT             usage,
  [out] VOID             **ppvBits,
  [in]  HANDLE           hSection,
  [in]  DWORD            offset
)
```
第四个参数的类型是`void** ppvBits`，[[数据结构#^7148fa|它期望接收一个指向指针的指针]]。函数将使用这个指针来返回一个指向DIB位图像素数据的指针。换句话说，<font color="#00b050">函数需要一个指针来存储它创建的另一个指针</font>。
CreateDIBSection函数使用hDC及BITMAPINFO结构信息创建一个指定大小等信息的位图，系统自动为其开辟所需的像素空间，开辟的像素空间地址就是用ppvBits参数返回的。而且此位图空间系统会自动释放。之所以需要返回此地址，是因为CreateDIBSection调用时只是根据我们提供的一些信息创建合适大小、格式的位图并开辟控件，而并不会填充实际像素值（这也是为什么我们直接将指向真实像素值的指针传入此函数中无效的原因），返回这个指针只是为了之后使用真实像素值填充此段空间（就像上面示例中的memcpy那样）！
#### 在BMP中画点

在bmp中画点，就是改变指定像素点的颜色，由于bmp是一个数组，所以就是改变指定元素的RGB值。

>[!Notice]
>
# 绘制直线

## Brensenham直线绘制算法

## 直线绘制

mCanvasBuffer被定义成了void*，表示一个指针，那么指向指针的指针应该是对mCanvasBuffer进行取指针操作才对呀？为什么会写成(void**)