---
tags:
  - ET8/CoroutineLock
---
# 协程锁（CoroutineLock）

> **对前端的类比**：Unity 的协程（Coroutine）是无法"加锁"的。如果两个协程同时修改同一数据，会产生竞争条件。ET 的协程锁就是为单线程异步环境设计的"锁"。

**问题场景**：

```csharp
// 两个消息同时到达，都要修改玩家数据
async ETTask Handler1(Player player) {
    var data = await DB.Query(player.Id);  // 从DB读取
    data.Gold += 100;
    await DB.Save(data);                    // 保存到DB
}

async ETTask Handler2(Player player) {
    var data = await DB.Query(player.Id);  // 这里读到的可能是 Handler1 还没保存的旧数据！
    data.Gold -= 50;
    await DB.Save(data);                    // 覆盖了 Handler1 的修改！
}
```

虽然是单线程，但 `await` 会让出执行权，导致交错执行。

**协程锁解决方案**：

```csharp
async ETTask Handler1(Player player) {
    using (await CoroutineLockComponent.Wait(CoroutineLockType.DB, player.Id)) {
        var data = await DB.Query(player.Id);
        data.Gold += 100;
        await DB.Save(data);
    } // using 结束自动释放锁
}

async ETTask Handler2(Player player) {
    using (await CoroutineLockComponent.Wait(CoroutineLockType.DB, player.Id)) {
        // Handler1 持有锁时,这里会 await 挂起
        // Handler1 释放锁后,才会继续执行
        var data = await DB.Query(player.Id);
        data.Gold -= 50;
        await DB.Save(data);
    }
}
```

**内部实现**：
- 每个 `(lockType, key)` 对应一个 `CoroutineLockQueue`
- 队列空闲时直接获得锁
- 队列占用时创建 `WaitCoroutineLock` 入队等待
- 当前锁 `Dispose` 时，从队列唤醒下一个等待者
- 支持**超时机制**，防止死锁

**常见 CoroutineLockType**：

| 类型 | 用途 |
|---|---|
| `Mailbox` | MailBoxComponent 的 OrderedMessage 串行处理 |
| `MessageLocationSender` | 同一 entityId 的 Location 消息串行发送 |
| `Location` | Location Server 的增删改查串行执行 |
| `DB` | 同一 Entity 的数据库操作串行执行 |

# 定时器（TimerComponent）

**三种定时器**：

| 类型 | API | 说明 |
|---|---|---|
| **一次性回调** | `NewOnceTimer(time, type, args)` | 到点触发一次 |
| **一次性 await** | `WaitAsync(ms)` / `WaitTillAsync(time)` | 异步等待，类似 `Task.Delay` |
| **重复定时器** | `NewRepeatedTimer(interval, type, args)` | 周期性触发 |

```csharp
// 等待 3 秒
await TimerComponent.WaitAsync(3000);

// 5 秒后执行一次回调
TimerComponent.NewOnceTimer(TimeInfo.Instance.ServerNow() + 5000, TimerInvokeType.MyCallback, args);

// 每 1 秒执行一次
long timerId = TimerComponent.NewRepeatedTimer(1000, TimerInvokeType.HeartBeat, args);
```

**内部实现**：基于 `MultiMap<long, long>`（触发时间 → timerId 列表），每帧检查 `minTime`，到点触发。

---
