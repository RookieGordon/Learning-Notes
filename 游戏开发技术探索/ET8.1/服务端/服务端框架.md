---
tags:
  - ET8/框架介绍/服务器架构
  - ET8
---
# 一、游戏服务器概述

## 1.1 对前端程序员的类比

如果你熟悉 Unity 前端开发，可以用以下类比来理解游戏服务器：

| Unity 前端概念 | 游戏服务器对应概念 |
|---|---|
| MonoBehaviour 的 `Update()` 循环 | 服务器的主循环（每帧处理消息、更新逻辑） |
| 场景（Scene） | 服务器的逻辑分区（如一个地图实例） |
| `GameObject` + `Component` | 服务端的 Entity + Component（ET 的 ECS） |
| `SendMessage()` / 事件系统 | Actor 消息 / RPC 调用 |
| Unity 的单线程模型 | ET 的 Fiber 模型（多个"单线程"并行） |
| Prefab 实例化 | 服务器创建玩家实体、NPC 实体 |

## 1.2 游戏服务器面临的核心挑战

1. **高并发**：成千上万玩家同时在线，每秒数万条消息
2. **低延迟**：玩家操作需要快速响应（<100ms）
3. **状态一致性**：多个玩家看到的游戏世界必须一致
4. **可扩展性**：单机承载有限，需要分布式部署
5. **热更新**：不停服更新游戏逻辑
6. **容错性**：单点故障不能导致整个服务崩溃

ET 框架的每一个核心设计点，都是为了解决上述一个或多个问题。

---

# 二、ET 服务端整体架构总览

## 2.1 架构全景图

```
┌──────────────────────────────────────────────────────────────┐
│                     World (进程级全局管理)                      │
│   FiberManager / OpcodeType / NetServices / CodeTypes ...     │
├──────────────────────────────────────────────────────────────┤
│ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐        │
│ │Main Fiber│ │NetInner  │ │ Realm    │ │  Gate    │ ...     │
│ │  (入口)   │ │Fiber     │ │ Fiber    │ │  Fiber   │        │
│ │          │ │(内网通信) │ │(登录验证) │ │ (网关)    │        │
│ └──────────┘ └──────────┘ └──────────┘ └──────────┘        │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐                     │
│ │Location  │ │   Map    │ │  Match   │ ...                  │
│ │Fiber     │ │  Fiber   │ │  Fiber   │                     │
│ │(位置服务) │ │ (地图)    │ │ (匹配)   │                     │
│ └──────────┘ └──────────┘ └──────────┘                     │
│                                                              │
│           MessageQueue (Fiber间消息队列)                       │
├──────────────────────────────────────────────────────────────┤
│                  Network Layer                                │
│     KService(KCP/UDP)  TService(TCP)  WService(WebSocket)    │
└──────────────────────────────────────────────────────────────┘
      ↑↓ 客户端连接              ↑↓ 进程间连接
```

## 2.2 分层说明

| 层次 | 职责 | 关键类 |
|------|------|--------|
| **World 层** | 进程级全局单例管理 | `World`, `Singleton<T>`, `FiberManager` |
| **Fiber 层** | 独立执行上下文，每个 Fiber 有自己的 Update 循环 | `Fiber`, `EntitySystem`, `Mailboxes` |
| **Entity 层** | 业务数据和逻辑的载体（ECS 模式） | `Entity`, `Scene`, `Component` |
| **Actor 层** | 基于 MailBox 的消息驱动模型 | `MailBoxComponent`, `MessageDispatcher`, `IMHandler` |
| **通信层** | 进程内/跨进程消息路由 | `ProcessInnerSender`, `MessageSender`, `ProcessOuterSender` |
| **网络层** | 底层传输协议 | `KService`, `TService`, `WService`, `AChannel` |

## 2.3 关键设计哲学

> **"单线程多进程"** — 每个 Fiber 内部是单线程的（避免锁），多个 Fiber 并行执行（提升吞吐）。这是 ET 最核心的设计思想，贯穿所有子系统。

---

# 三、服务端启动流程详解

## 3.1 启动链路

```
Program.Main()
  │
  ├─ 1. Init.Start()
  │     ├─ 解析命令行参数 → Options 单例
  │     │   (AppType, Process, StartConfig, LogLevel...)
  │     ├─ 初始化核心单例
  │     │   Logger / TimeInfo / FiberManager
  │     └─ CodeLoader.Awake()
  │         ├─ 加载 Model.dll (数据定义)
  │         ├─ 加载 Hotfix.dll (逻辑代码,支持热重载)
  │         └─ Entry.Start() → 创建 Main Fiber
  │
  ├─ 2. FiberInit_Main → 分发初始化事件
  │     ├─ EntryEvent1: 共享初始化
  │     │   Timer / CoroutineLock / MailBox / ProcessInnerSender
  │     │
  │     ├─ EntryEvent2: 服务端初始化 (AppType=Server时)
  │     │   ├─ 创建 NetInner Fiber (进程间通信)
  │     │   └─ 遍历 StartSceneConfig 创建所有场景 Fiber:
  │     │       ├─ Realm Fiber → FiberInit_Realm
  │     │       ├─ Gate Fiber  → FiberInit_Gate
  │     │       ├─ Location Fiber → FiberInit_Location
  │     │       ├─ Map Fiber → FiberInit_Map
  │     │       └─ ...
  │     │
  │     └─ EntryEvent3: (客户端初始化,服务端无操作)
  │
  └─ 3. 主循环 (1ms 间隔)
        while(true) {
            Init.Update()     → World 更新所有单例
            Init.LateUpdate() → World 延迟更新
            Thread.Sleep(1)
        }
```

## 3.2 配置驱动

服务器的部署拓扑完全由配置决定：

**StartSceneConfig** 示例：
```
| Id    | Process | Zone | SceneType | Name     | Port  |
|-------|---------|------|-----------|----------|-------|
| 10001 | 1       | 1    | Realm     | Realm1   | 20001 |
| 10002 | 1       | 1    | Gate      | Gate1    | 20002 |
| 10003 | 1       | 1    | Gate      | Gate2    | 20003 |
| 10004 | 1       | 0    | Location  | Location | 0     |
| 10005 | 1       | 1    | Map       | Map1     | 0     |
```

- `Process=1` 表示这些 Fiber 都在进程 1 中（单进程开发模式）
- 改为 `Process=2` 即可将该 Fiber 拆到另一个进程
- `Port` 非零表示该 Fiber 监听外网端口（如 Gate 接收客户端连接）

---

# 四、游戏服务器通用知识科普

## 4.1 游戏服务器的常见架构模式

### 模式一：单体架构（Monolithic）

```
┌─── 单个服务器进程 ───┐
│ 所有逻辑在一起        │ ← 简单但扩展性差
│ 登录 + 游戏 + 匹配    │
└──────────────────────┘
```

**优点**：简单、延迟低（无网络开销）
**缺点**：无法水平扩展、单点故障

### 模式二：微服务架构（Microservices）

```
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│Login│ │Gate │ │Game │ │Chat │ ← 各司其职
└──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘
   └───────┴───────┴───────┘
          消息总线/RPC
```

**优点**：可独立扩展、隔离故障
**缺点**：复杂度高、网络延迟

### ET 的模式：融合架构

ET 通过 Fiber 实现了两种模式的融合：
- **开发时**像单体架构（所有 Fiber 在一个进程，调试方便）
- **部署时**像微服务架构（Fiber 可分布到不同进程/机器）

## 4.2 网关（Gate）的作用

```
客户端1 ─┐                 ┌─ Map1 (地图服)
客户端2 ─┼─ Gate (网关) ──┼─ Map2
客户端3 ─┘    │            └─ Map3
              │
              ├─ 连接管理（维护客户端Session）
              ├─ 消息路由（转发到正确的目标服务）
              ├─ 协议转换（Outer消息 → Inner消息）
              └─ 负载均衡（选择合适的Map服务）
```

Gate 网关的核心职责：
1. **维护客户端连接**：一个客户端对应一个 Session
2. **消息路由**：根据消息类型转发到对应的后端服务
3. **安全屏障**：客户端只能连接 Gate，不能直接访问内部服务
4. **GateSession MailBox**：收到发给玩家的消息后，直接通过 Session 转发给客户端

## 4.3 登录流程示例

```
客户端                  Realm              Gate               Map
  |                      |                  |                  |
  |--- C2R_Login ------->|                  |                  |
  |                      |-- 验证账号 ------>|                  |
  |<-- R2C_Login --------|                  |                  |
  |    (GateAddr, Key)   |                  |                  |
  |                      |                  |                  |
  |--- C2G_LoginGate ----|----------------->|                  |
  |    (Key)             |                  |-- 验证Key          |
  |                      |                  |-- 创建Player      |
  |<-- G2C_LoginGate ----|------------------|                  |
  |    (PlayerId)        |                  |                  |
  |                      |                  |                  |
  |--- C2G_EnterMap -----|----------------->|                  |
  |                      |                  |--- G2M_Create -->|
  |                      |                  |    (PlayerInfo)  |
  |                      |                  |<-- M2G_Create ---|
  |<-- G2C_EnterMap -----|------------------|    (UnitInfo)    |
  |    (MapInfo)         |                  |                  |
```

1. 客户端先连接 Realm 验证账号
2. Realm 返回网关地址和临时密钥
3. 客户端用密钥连接 Gate
4. Gate 创建 Player 并通知 Map 创建游戏实体

## 4.4 AOI（Area of Interest）

AOI 是游戏服务器中非常重要的优化技术：

```
200x200 的大地图上有 10000 个玩家
如果每个玩家都向所有人同步位置 → 10000 × 10000 = 1亿次/帧 ← 不可能！

AOI 解决方案：
┌────────┬────────┬────────┐
│ 区域1   │ 区域2   │ 区域3   │
│ 玩家A,B │ 玩家C   │ 玩家D   │
├────────┼────────┼────────┤
│ 区域4   │ 区域5   │ 区域6   │
│ 玩家E   │ 玩家F,G │        │
├────────┼────────┼────────┤
│ 区域7   │ 区域8   │ 区域9   │
│        │ 玩家H   │ 玩家I   │
└────────┴────────┴────────┘

玩家F 只需要同步给 周围9格 内的玩家(E,C,D,F,G,H,I)
而不是全部 10000 个玩家
```

ET 中通过 `AOIManagerComponent` 实现此功能。

## 4.5 帧同步 vs 状态同步

| | 状态同步 | 帧同步 |
|---|---|---|
| 服务器职责 | 计算完整游戏逻辑 | 只转发玩家输入 |
| 客户端职责 | 接收并渲染服务器结果 | 接收输入 + 完整模拟 |
| 带宽消耗 | 高（同步所有状态） | 低（只同步输入） |
| 反作弊 | 好（服务器权威） | 差（客户端计算） |
| 适合类型 | MMO、MOBA | 格斗、RTS |
| ET 支持 | Map Fiber | Room/RoomRoot Fiber |

ET 同时支持两种模式，分别通过 `Map` 和 `Room/RoomRoot` 场景类型实现。

## 4.6 数据库设计

ET 使用 **MongoDB** 作为数据库，这在游戏服务器中非常常见：

| 为什么选 MongoDB | 说明 |
|---|---|
| **Schema-free** | 游戏开发迭代快，字段频繁变更，不需要改表结构 |
| **BSON 格式** | 与 ET 的 Entity 序列化天然兼容 |
| **高性能写入** | 游戏需要频繁保存玩家数据 |
| **文档模型** | 一个玩家的所有数据存一个文档，读写一次完成 |

ET 通过 `DBComponent` 封装了数据库操作，每个操作都使用 `CoroutineLock` 保证同一 Entity 的读写串行执行。

---

# 附录：关键源码文件索引

## 核心框架（Core）

| 文件 | 说明 |
|---|---|
| `Unity/Assets/Scripts/Core/Entity/Entity.cs` | Entity 基类，983 行核心代码 |
| `Unity/Assets/Scripts/Core/Entity/Scene.cs` | 场景实体，Fiber 的根 |
| `Unity/Assets/Scripts/Core/Entity/EntitySystemSingleton.cs` | System 注册与调用中心 |
| `Unity/Assets/Scripts/Core/Fiber/Fiber.cs` | Fiber 纤程 |
| `Unity/Assets/Scripts/Core/Fiber/MailBoxComponent.cs` | Actor 邮箱 |
| `Unity/Assets/Scripts/Core/Fiber/Module/Actor/ProcessInnerSender.cs` | 进程内消息发送 |
| `Unity/Assets/Scripts/Core/World/World.cs` | 全局单例容器 |
| `Unity/Assets/Scripts/Core/World/Module/Fiber/FiberManager.cs` | Fiber 管理器 |
| `Unity/Assets/Scripts/Core/World/Module/Actor/MessageQueue.cs` | Fiber 间消息队列 |
| `Unity/Assets/Scripts/Core/World/Module/Actor/MessageDispatcher.cs` | 消息分发器 |
| `Unity/Assets/Scripts/Core/World/ActorId.cs` | Actor 地址定义 |

## 网络层（Network）

| 文件 | 说明 |
|---|---|
| `Unity/Assets/Scripts/Core/Network/KService.cs` | KCP 服务（633行） |
| `Unity/Assets/Scripts/Core/Network/KChannel.cs` | KCP 通道 |
| `Unity/Assets/Scripts/Core/Network/TService.cs` | TCP 服务 |
| `Unity/Assets/Scripts/Core/Network/TChannel.cs` | TCP 通道（376行） |
| `Unity/Assets/Scripts/Core/Network/WService.cs` | WebSocket 服务 |
| `Unity/Assets/Scripts/Core/Network/MessageSerializeHelper.cs` | 消息序列化 |
| `Unity/Assets/Scripts/Core/Network/OpcodeType.cs` | Opcode 管理 |

## 服务端业务（Server）

| 文件 | 说明 |
|---|---|
| `Unity/Assets/Scripts/Hotfix/Server/Module/Message/MessageSenderSystem.cs` | 跨进程消息路由 |
| `Unity/Assets/Scripts/Model/Server/Module/Message/ProcessOuterSender.cs` | 跨进程网络发送 |
| `Unity/Assets/Scripts/Hotfix/Server/Module/ActorLocation/LocationOneTypeSystem.cs` | Location 核心操作 |
| `Unity/Assets/Scripts/Hotfix/Server/Module/ActorLocation/MessageLocationSenderComponentSystem.cs` | Location 消息发送 |
| `Unity/Assets/Scripts/Hotfix/Server/Module/DB/DBComponentSystem.cs` | 数据库 CRUD |
| `Unity/Assets/Scripts/Hotfix/Server/Demo/EntryEvent2_InitServer.cs` | 服务端启动入口 |

## Fiber 初始化

| 文件 | 对应 SceneType |
|---|---|
| `Unity/Assets/Scripts/Hotfix/Share/FiberInit_Main.cs` | Main |
| `Unity/Assets/Scripts/Hotfix/Server/Module/NetInner/FiberInit_NetInner.cs` | NetInner |
| `Unity/Assets/Scripts/Hotfix/Server/Demo/Realm/FiberInit_Realm.cs` | Realm |
| `Unity/Assets/Scripts/Hotfix/Server/Demo/Gate/FiberInit_Gate.cs` | Gate |
| `Unity/Assets/Scripts/Hotfix/Server/Module/ActorLocation/FiberInit_Location.cs` | Location |
| `Unity/Assets/Scripts/Hotfix/Server/LockStep/Map/FiberInit_Map.cs` | Map |

## 参考书籍

| 文件 | 主题 |
|---|---|
| `Book/5.4Actor模型.md` | Actor 模型设计思想 |
| `Book/5.5Actor Location-ZH.md` | Actor Location 详解 |
| `Book/4.1组件式设计.md` | 组件化设计理念 |
| `Book/3.3一切皆实体.md` | Entity 设计理念 |
| `Book/2.1CSharp的协程.md` | C# 协程机制 |
| `Book/2.3单线程异步.md` | 单线程异步编程 |

---

> **总结**：ET 框架通过 **Fiber 纤程** 实现了"单线程安全 + 多核并行"的并发模型，通过 **Actor + MailBox** 实现了消息驱动的通信范式，通过 **Location** 解决了可迁移实体的寻址问题，通过 **ECS** 实现了数据与逻辑分离（支持热更新），通过 **配置驱动** 实现了"开发时单进程、部署时分布式"的灵活扩展能力。这些设计环环相扣，共同构成了一个完整的、适合游戏场景的分布式服务框架。
