

  

## ET 框架 Actor 模型讲解

ET 框架实现了一套基于 **Fiber（纤程）** 的 Actor 模型，核心目标是：**让分布在不同纤程、不同进程上的 Entity 能够互相通信，且业务代码无需关心底层传输细节。**

---

### 一、Actor 寻址：ActorId 三级地址

每个 Actor 通过 `ActorId` 唯一标识，结构为三级寻址：

```
ActorId = { Process（进程号）, Fiber（纤程号）, InstanceId（实体实例ID）}
```

| 层级 | 含义 | 作用 |
|------|------|------|
| **Process** | 目标所在的操作系统进程 | 决定走本地投递还是网络传输 |
| **Fiber** | 进程内的逻辑纤程 | 决定投递到哪个消息队列 |
| **InstanceId** | 纤程内挂有 `MailBoxComponent` 的 Entity | 最终定位到具体的 Actor 实体 |

获取一个 Entity 的 ActorId 非常简单（见 Fiber.cs）：
```csharp
ActorId actorId = new ActorId(fiber.Process, fiber.Id, entity.InstanceId);
```

---

### 二、核心组件协作关系

```
┌─────────────────────────────────────────────────────────┐
│                    同进程 (Process)                       │
│                                                          │
│  ┌──────────┐   MessageQueue    ┌──────────┐            │
│  │ Fiber A  │ ──────────────→  │ Fiber B  │            │
│  │ProcessIn-│  (ConcurrentQueue) │ProcessIn-│            │
│  │nerSender │ ←──────────────  │nerSender │            │
│  └──────────┘                   └────┬─────┘            │
│                                      │                   │
│                                      ▼                   │
│                               MailBoxComponent           │
│                                      │                   │
│                               MessageDispatcher          │
│                                      │                   │
│                               业务 Handler               │
│                                                          │
│  ┌──────────────┐                                        │
│  │ NetInner Fiber│─── ProcessOuterSender ──→ 网络(TCP) ──→ 其他进程
│  └──────────────┘                                        │
└─────────────────────────────────────────────────────────┘
```

各组件职责：

| 组件 | 职责 |
|------|------|
| **MessageQueue** | 全局单例，用 `ConcurrentDictionary<int, ConcurrentQueue<MessageInfo>>` 维护每个 Fiber 的消息队列，是**跨纤程投递的中枢** |
| **ProcessInnerSender** | 每个 Fiber 各一个。发送时往 MessageQueue 塞消息；每帧 `Update` 时从队列 Fetch 消息处理 |
| **MailBoxComponent** | 挂在目标 Entity 上，标记该 Entity 为一个 Actor。按 `MailBoxType` 分发（有序 / 无序 / Gate转发） |
| **ProcessOuterSender** | 运行在 NetInner Fiber 上，负责**跨进程**的网络收发，收到远程消息后转交 ProcessInnerSender 投递到本地 Fiber |
| **MessageSender** | 服务器业务层的统一发送抽象，自动判断同进程/跨进程路由 |
| **ClientSenderComponent** | 客户端发送抽象，将请求包装后从 Main Fiber 投递到 NetClient Fiber |

---

### 三、客户端消息流转（对应「客户端消息流转.drawio」）

客户端采用**双 Fiber 架构**：**Main Fiber**（业务逻辑）和 **NetClient Fiber**（网络 IO），两者通过 Actor 消息通信：

```
发送请求：
  ① 业务代码调用 ClientSenderComponent.Call(IRequest)
  ② 将 IRequest 包装进 A2NetClient_Request
  ③ 通过 ProcessInnerSender.Call() → MessageQueue → NetClient Fiber 队列
  ④ NetClient Fiber 的 ProcessInnerSender.Update() 拉取消息
  ⑤ MailBoxComponent 分发 → A2NetClient_RequestHandler 解包
  ⑥ 调用 Session.Call() 通过 TCP/KCP 发送到服务器

收到回包：
  ⑦ 服务器返回 → NetComponent.OnRead() → NetComponentOnReadInvoker_NetClient
  ⑧ 如果是 Response：封入 A2NetClient_Response → Reply 回 Main Fiber
  ⑨ 如果是服务器主推 IMessage：通过 ProcessInnerSender.Send() 转发到 Main Fiber
  ⑩ Main Fiber 的 ProcessInnerSender.Update() 拉取 → HandleIActorResponse → ETTask 完成
```

这里 drawio 图中的 **Alt 分支**体现了关键判断：`ProcessInnerSender.SendInner()` 会检查目标 Fiber 是否在 MessageQueue 中注册过（`messages.ContainsKey(actorId.Address.Fiber)`），如果找不到则返回 `ERR_NotFoundActor`。

---

### 四、服务器消息流转

#### 同进程 Fiber 间通信

```
Fiber A 发送:
  MessageSender.Send(actorId, msg)
    → actorId.Process == 当前进程
    → ProcessInnerSender.Send() → MessageQueue.Send() → 目标 Fiber 队列

目标 Fiber 接收:
  ProcessInnerSender.Update() → Fetch()
    → HandleMessage() → Mailboxes.Get(instanceId) → MailBoxComponent.Add()
      → 按 MailBoxType 分发:
        · OrderedMessage: 加协程锁保证有序 → MessageDispatcher.Handle()
        · UnOrderedMessage: 直接 MessageDispatcher.Handle()
        · GateSession: 直接将消息发送给客户端
```

#### 跨进程通信

```
Fiber A (Process 1):
  MessageSender.Send(actorId, msg)    // actorId.Process ≠ 当前进程
    → 包装为 A2NetInner_Message → MessageQueue → NetInner Fiber

NetInner Fiber (Process 1):
  A2NetInner_MessageHandler → ProcessOuterSender.Send()
    → 通过 TCP Session 序列化发送到 Process 2 的网络端口

NetInner Fiber (Process 2):
  ProcessOuterSender.OnRead() → 反序列化
    → ProcessInnerSender.Send(actorId, msg) → MessageQueue → 目标 Fiber

目标 Fiber (Process 2):
  正常 Actor 消息处理 → MailBoxComponent → 业务 Handler
```

---

### 五、Actor 模型的设计精髓

1. **统一的消息投递机制**：无论同纤程、跨纤程、跨进程，业务代码都通过 `MessageSender.Send/Call` 一个接口完成，路由逻辑完全透明。

2. **MessageQueue 解耦并发**：所有纤程间通信都经过 `ConcurrentQueue`，每个 Fiber 在自己的 `Update` 中拉取消息，天然实现了**单线程消费**，避免了锁竞争。

3. **二次封装隔离网络层**：
   - 客户端用 `A2NetClient_Request/Response` 包装，隔离 Main Fiber 与 NetClient Fiber
   - 服务器用 `A2NetInner_Message/Request/Response` 包装，隔离业务 Fiber 与 NetInner Fiber

4. **MailBoxType 策略模式**：`OrderedMessage` 使用协程锁保证消息有序处理（适合状态敏感的游戏逻辑），`UnOrderedMessage` 不加锁追求吞吐量，`GateSession` 特化为网关转发。

5. **Request/Response 异步 RPC**：`ProcessInnerSender.Call()` 注册 RpcId 回调 + 40s 超时，收到 IResponse 时自动匹配 `SetResult()` 完成 ETTask——实现了 Actor 模型上的 **async/await 风格 RPC**。