---
tags:
  - ET8/网络框架/框架
  - ET8
  - ET8/Mailboxes
  - ET8/MailBoxComponent
---
# Mailboxes邮箱

每个`Fiber`都有一个邮箱`Mailboxes`，外界只能通过邮箱来和`Fiber`进行通信，通过对比[[网络协议收发#^3a23da|ProcessInnerSender.HandleMessage]]方法，可以得知，每个`Actor`消息，都会配置一个`MailBoxComponent`组件，一个`Fiber`则会通过`Mailboxes`字段，持有多个`MailBoxComponent`组件。

```CSharp
private readonly Dictionary<long, MailBoxComponent> mailboxes = new();
```

# MailBoxComponent组件

```CSharp
public class MailBoxComponent: Entity, IAwake<MailBoxType>, IDestroy  
{  
    public long ParentInstanceId { get; set; }  
    // Mailbox的类型  
    public MailBoxType MailBoxType { get; set; }  
}
```

`ParentInstanceId`字段表示其父`Entity`节点的id。需要通讯的组件，都可以挂邮箱组件。
`Add`方法用于处理`Fiber`（通过`ProcessInnerSender`组件）接收到的消息，通过该邮箱，将消息按照邮箱的类型派发出去处理。

## 邮箱类型

```CSharp
public enum MailBoxType  
{  
    OrderedMessage = 1,  
    UnOrderedMessage,  
    GateSession,  
}
```

目前有三种邮箱类型，邮箱收到的消息是按照邮箱类型，再次分发处理的。
`UnOrderedMessage`和`OrderedMessage`类型，最终都是通过`MessageDispatcher`单例对象，分发处理。

`MessageDispatcher`单例对象，在初始化的时候，会收集到所有被`MessageHandlerAttribute`和`MessageLocationHandlerAttribute`特性修饰的类，由此可以推测出，所有的消息处理的对象，需要被这两个特性所修饰。所有的消息处理对象，会按照消息的类型，分类储存

```CSharp
private readonly Dictionary<Type, List<MessageDispatcherInfo>> messageHandlers = new();
```

`UnOrderedMessage`类型的邮箱，收到的消息直接使用`MessageDispatcher`派发出去处理。
`OrderedMessage`类型的邮箱，在处理消息时，会锁住当前的邮箱，使用`MessageDispatcher`派发出去处理，等待处理结束后，再解锁当前邮箱，处理下一个消息。