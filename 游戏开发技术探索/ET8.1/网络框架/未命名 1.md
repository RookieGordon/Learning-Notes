

 ## MailBoxComponent 在 Actor 模型中的角色

**MailBoxComponent 就是 Actor 的"信箱"——它是将普通 Entity 变成 Actor 的关键标记。** 挂上这个组件的 Entity，就拥有了接收和处理 Actor 消息的能力。

---

### 核心职责

**1. 注册为 Actor**

`MailBoxComponent` 挂载在目标 Entity 上（作为子组件）。Awake 时将自身注册到所在 Fiber 的 `Mailboxes` 字典中（key = 父 Entity 的 InstanceId），Destroy 时移除：

```csharp
// 注册后，ProcessInnerSender 收到消息时就能通过 InstanceId 找到这个信箱
MailBoxComponent mailBoxComponent = fiber.Mailboxes.Get(actorId.InstanceId);
```

这意味着：**没有 MailBoxComponent 的 Entity 无法被 Actor 消息寻址到**。`ProcessInnerSender.HandleMessage()` 找不到对应 MailBoxComponent 时会直接返回 `ERR_NotFoundActor`。

**2. 消息入口：接收投递**

当 `ProcessInnerSender` 从 MessageQueue 拉取到消息并通过 InstanceId 定位到 MailBoxComponent 后，调用其 `Add()` 方法投递消息。

**3. 策略分发：按 MailBoxType 决定处理方式**

`Add()` 内部通过 `EventSystem.Invoke()` 按 `MailBoxType` 分派到不同的 Handler：

| MailBoxType | 行为 | 适用场景 |
|---|---|---|
| **OrderedMessage** | 使用**协程锁**（`CoroutineLock`，锁 key = ParentInstanceId）保证消息**严格有序**处理，然后调用 `MessageDispatcher.Handle()` | 状态敏感的游戏逻辑（如玩家实体），防止并发修改状态 |
| **UnOrderedMessage** | **不加锁**，直接调用 `MessageDispatcher.Handle()` | 无状态或对顺序不敏感的服务，追求吞吐量 |
| **GateSession** | 不走 MessageDispatcher，直接将消息通过 Session **转发给客户端** | Gate 服务器上的玩家 Session，实现服务器主推消息到客户端 |

---

### 在消息流转中的位置

```
MessageQueue (跨纤程队列)
    │
    ▼
ProcessInnerSender.Update() → Fetch 拉取消息
    │
    ▼
ProcessInnerSender.HandleMessage()
    │  按 InstanceId 查找
    ▼
 ★ MailBoxComponent.Add()  ← 你在这里
    │  按 MailBoxType 分发
    ▼
OrderedMessage / UnOrderedMessage / GateSession Handler
    │
    ▼
MessageDispatcher.Handle() → 具体业务 Handler
```

---

### 一句话总结

**MailBoxComponent 是 Actor 模型中"信箱"的实体化**——它标记一个 Entity 为可寻址的 Actor，接收投递过来的消息，并根据策略（有序/无序/网关转发）决定如何将消息交给业务层处理。没有它，Entity 就只是普通数据容器；有了它，Entity 就成了能收发消息的 Actor。