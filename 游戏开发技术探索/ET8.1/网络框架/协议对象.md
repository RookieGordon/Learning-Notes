---
tags:
  - ET8/网络框架/框架
  - ET8
  - ET8/网络协议
---
# 基础消息对象

`IRequest`和`IReponse`是协议对象的接口，在订立协议的时候，需要注意格式，如下是《ClientMessage_C_1000.proto》协议文件的部分内容：

```protobuf
// ResponseType NetClient2Main_Login
message Main2NetClient_Login // IRequest
{
	int32 RpcId = 1;
	int32 OwnerFiberId = 2;
	string Account = 3;		// 账号
	string Password = 4; 	// 密码
}

message NetClient2Main_Login // IResponse
{
	int32 RpcId = 1;
	int32 Error = 2;
	string Message = 3;
	int64 PlayerId = 4;
}
```

协议同一行，注明协议类型（即注明是继承`IRequest`还是`IReponse`）。并且，如果请求的协议有返回，还使用`ResponseType`特性注明返回协议的类型。这些注释在进行协议导出的时候，都会被提取出来，进而补充额外的信息。

观察协议导出的CS文件（《ClientMessage_C_1000.cs》）可以发现，每个协议都继承自`MessageObject`基类，根据协议类型不同，实现`IRequest`或`IReponse`接口。

`MemoryPackable`是用于协议序列化的接口。通过`MemoryPackSerializer`工具，将协议序列化和反序列化。

使用`Message`特性描述协议的协议号（协议号定义在`ClientMessage`对象中）。有对应返回协议的，使用`ResponseType`特性描述其对应的返回协议类型：

```CSharp
public class MessageAttribute: BaseAttribute  
{  
    public ushort Opcode  {  get;  }  
}

public class ResponseTypeAttribute: BaseAttribute  
{  
    public string Type { get; }  
}
```

一个典型的协议对象如下：

```CSharp
[MemoryPackable]
[Message(ClientMessage.Main2NetClient_Login)]
[ResponseType(nameof(NetClient2Main_Login))]
public partial class Main2NetClient_Login : MessageObject, IRequest
{
    public static Main2NetClient_Login Create(bool isFromPool = false)
    {
        return ObjectPool.Instance.Fetch(typeof(Main2NetClient_Login), isFromPool) as Main2NetClient_Login;
    }

    [MemoryPackOrder(0)]
    public int RpcId { get; set; }

    // 其他协议字段
  
    public override void Dispose()
    {
        if (!this.IsFromPool)
        {
            return;
        }

        this.RpcId = default;
        // 其他字段同样设为default
        ObjectPool.Instance.Recycle(this);
    }
}

[MemoryPackable]
[Message(ClientMessage.NetClient2Main_Login)]
public partial class NetClient2Main_Login : MessageObject, IResponse
{
    // .....
}

public static class ClientMessage
{
    public const ushort Main2NetClient_Login = 1001;
    public const ushort NetClient2Main_Login = 1002;
}
```

协议都是可以回收的，`MessageObject`继承自`ProtoObject`

# 几种消息对象的扩展

除了基础的`IMessage`，`IRequest`和`IResponse`外，还有另外几个派生的协议类型，它们的区别如下：

| 接口                     | 处理位置                | 是否需要回复     | 路由方式                                                                 | 典型场景                             |
| :--------------------- | :------------------ | :--------- | :------------------------------------------------------------------- | :------------------------------- |
| **`ISessionMessage`**  | **Gate 本地**         | 看子接口       | 不转发，Gate 的 `MessageSessionDispatcher` 直接处理                           | `C2G_LoginGate` 等 Gate 自己处理的请求   |
| **`FrameMessage`**     | **Room Fiber**      | 否（单向）      | 通过 `MessageSender` 直接发送到 `roomActorId`                               | 帧同步的帧输入数据                        |
| **`IRoomMessage`**     | **Room Fiber**      | 否（单向）      | 同上，附带 `PlayerId`                                                     | 帧同步房间相关消息                        |
| **`ILocationMessage`** | **目标 Actor（如 Map）** | 否（单向）      | 通过 `MessageLocationSenderComponent` + Location 系统解析 unitId → ActorId | 向 Unit 发通知（如 AOI 广播）             |
| **`ILocationRequest`** | **目标 Actor（如 Map）** | **是（RPC）** | 同上，但 Gate **保存客户端 RpcId**，await 等回包后恢复 RpcId 回复客户端                   | 客户端向 Map 上的 Unit 发 RPC 请求（如技能释放） |
| **`IRequest`**         | 未实现                 | 是          | 需自行扩展                                                                | 预留的直接 Actor RPC                  |
| **`IMessage`**         | 未实现                 | 否          | 需自行扩展                                                                | 预留的直接 Actor 单向消息                 |
**它们的继承关系如下**

```
IMessage                          ← 最基础接口，单向通知，无需返回
├── IRequest                      ← 有 RpcId，需要等待 IResponse 返回
│   └── ILocationRequest          ← 需要通过 Location 系统路由到目标 Actor
│       └── ILocationMessage      ← ILocationRequest 的单向版（虽继承自 IRequest，但语义上不需要回复）
├── ISessionMessage               ← 标记为 Gate 本地直接处理
│   ├── ISessionRequest           ← Gate 本地 RPC
│   └── ISessionResponse          ← Gate 本地 RPC 回复
├── IRoomMessage                  ← 帧同步房间消息，携带 PlayerId
└── FrameMessage                  ← 帧同步帧消息（具体类，直接实现 IMessage）
```

**关键差异总结**

1. **`ISessionMessage` vs 其他**：唯一在 **Gate Fiber 本地处理**的消息，不跨 Fiber 转发
2. **`ILocationMessage` vs `ILocationRequest`**：都经 Location 路由，区别是 `ILocationMessage` **只发不等回复**（fire-and-forget），`ILocationRequest` 是 **RPC 需要 await 回复**，且 Gate 要做 RpcId 的保存/恢复
3. **`FrameMessage`/`IRoomMessage` vs `ILocationXxx`**：路由方式不同——前者已知目标 `roomActorId`，直接通过 `MessageSender.Send()` 发送；后者只知道 `unitId`，需要经过 **Location 系统**查询才能得到 ActorId
4. **`IRequest`/`IMessage`**（未实现）：代码注释说"目前没有用到"，这两个 case 是预留给**不经 Location 路由、但需要跨 Fiber 的直接 Actor 通信**场景，需要开发者自行补充转发逻辑