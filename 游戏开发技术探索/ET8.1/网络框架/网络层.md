---
tags:
  - ET8/网络框架/框架 
  - ET8
---
# 核心设计理念：三层分离

ET 的网络层采用 **Service → Channel → Session** 三层架构，每层职责清晰：

```
业务逻辑层    Session         —— "谁在通信"（逻辑连接，Entity 体系内）
服务管理层    AService        —— "怎么管理"（连接池 + 事件驱动）
传输通道层    Channel         —— "怎么传输"（字节流收发 + 协议解析）
```

关键设计点：**Session 和 Channel 不直接引用对方**，而是通过 `channelId` 间接关联。

![[（图解1）网络通信框架.drawio.png]]

---

# 一、Channel（传输通道层）

Channel 是最底层的"管道"，直接操作 Socket / KCP，负责**字节流的读写和协议拆包**。

**`TChannel`（TCP）的设计：**

```
Socket ←→ [recvBuffer (CircularBuffer)] → PacketParser → 完整包 → ReadCallback
           [sendBuffer (CircularBuffer)] ← 写入包头+包体 ← Send(buf)
```

- 使用两个 `CircularBuffer` 环形缓冲区分别处理收发，避免频繁内存分配
- `PacketParser` 按 **"包长度前缀"** 从连续字节流中切出完整消息包（解决 TCP 粘包/拆包）
- 所有 Socket 异步操作（`SendAsync` / `ReceiveAsync`）完成后，事件推入 `TService.Queue`（`ConcurrentQueue`），由主线程 `Update()` 统一处理——这是 **异步 IO → 单线程分发** 的经典模式

**`KChannel`（KCP/UDP）的设计：**

- 底层是 KCP 可靠传输协议，自带重传、拥塞控制
- 多了连接握手流程：`SYN → ACK → MSG`（类似简化 TCP 三次握手）
- `waitSendMessages` 缓存连接建立前的消息，连接成功后一次性发出
- `Output()` 是 KCP 的发送回调，加上 MSG 协议头后交给 `Transport.Send()`

**Channel 的核心原则**：只管字节，不懂消息。它**不知道**自己传输的是什么消息类型，只负责确保字节流可靠到达。收到完整包后，通过 `Service.ReadCallback(channelId, buffer)` 向上传递原始二进制数据。

---

# 二、AService（服务管理层）

Service 是 Channel 的**管理者和事件中枢**，是连接 Channel 和上层业务的桥梁。

```csharp
abstract class AService {
    // 三个回调 —— 上层注册，Service 在适当时机触发
    Action<long, IPEndPoint> AcceptCallback;   // 新连接接入
    Action<long, MemoryBuffer> ReadCallback;   // 收到数据
    Action<long, int> ErrorCallback;           // 连接出错

    // 四个抽象方法 —— 子类实现
    abstract Create(id, ipEndPoint);  // 主动创建连接
    abstract Send(channelId, buf);    // 发送数据
    abstract Remove(id, error);       // 移除连接
    abstract Update();                // 驱动轮询
}
```

**设计精髓——回调反转模式：**

Service 自身不知道上层是谁（不引用 NetComponent），而是通过三个 `Action` 回调将事件**上抛**。`NetComponent` 在 Awake 时注册这三个回调：

```
AService.AcceptCallback = NetComponent.OnAccept
AService.ReadCallback   = NetComponent.OnRead
AService.ErrorCallback  = NetComponent.OnError
```

这使得 Service/Channel 层完全**不依赖 Entity/Component 体系**，可以独立运行和测试。

**`TService` 的线程安全设计：**

参看 TService.cs ——`Queue` 是 `ConcurrentQueue<TArgs>`，所有 Socket 异步回调在 IO 线程将事件入队，`Update()` 在主线程出队处理。这是个**生产者-消费者**模型：

```
IO 线程: SocketAsyncEventArgs 完成 → Queue.Enqueue(event)
主线程: Update() → Queue.TryDequeue → 分发到对应 TChannel
```

保证了**所有业务逻辑在单线程执行**，避免并发问题。

**Service 拥有所有 Channel：**

```csharp
// TService
Dictionary<long, TChannel> idChannels;  // channelId → TChannel

// KService  
Dictionary<long, KChannel> localConnChannels;  // localConn → KChannel
```

channelId 是全局唯一的（由 `NetServices` 单例生成），Service 通过字典快速查找 Channel。

---

# 三、Session（业务逻辑层）

Session 是整个设计中最巧妙的部分：它是一个 **Entity**（融入 ET 的 ECS 体系），但又能驱动底层网络操作。

**核心设计：`Session.Id == channelId`**

```
NetComponent (Entity)
  └── Session (ChildOf, Id = 101)     ←——→    Channel (Id = 101, 在 Service 字典中)
  └── Session (ChildOf, Id = 201)     ←——→    Channel (Id = 201, 在 Service 字典中)
```

Session **不持有** Channel 引用，而是：

1. 持有 `AService` 的引用（和父级 NetComponent 共享同一个实例）
2. 用自己的 `Id`（即 channelId）通过 `AService.Send(self.Id, buf)` 定位到对应 Channel

这样做的好处：

- **解耦**：Session 在 Entity 体系中，Channel 在网络层中，互不直接引用
- **生命周期清晰**：`Session.Dispose()` 时调用 `AService.Remove(self.Id)`，自动销毁对应 Channel
- **统一模型**：无论 TCP 还是 KCP，Session 的 API 完全一致

**Session 的 RPC 机制：**

```csharp
// 请求-响应匹配
Dictionary<int, RpcInfo> requestCallbacks;  // rpcId → ETTask<IResponse>

// Call 流程
async Call(IRequest request) {
    int rpcId = ++nextRpcId;
    request.RpcId = rpcId;
    var tcs = ETTask<IResponse>.Create();
    requestCallbacks[rpcId] = new RpcInfo(tcs);
    Send(request);           // 发出去
    return await tcs;        // 挂起等待
}

// 收到响应时
OnResponse(IResponse response) {
    if (requestCallbacks.Remove(response.RpcId, out var rpcInfo)) {
        rpcInfo.SetResult(response);  // 唤醒 await
    }
}
```

这是经典的 **RpcId 匹配模式**：发请求时生成唯一 RpcId 并注册等待任务，收到响应时按 RpcId 找到对应任务并完成。使得异步网络调用可以写成同步风格的 `await session.Call(request)`。

---

# 四、三者如何协作

**发送路径（自上而下）：**

```
Session.Send(IMessage)
  → MessageSerializeHelper.ToMemoryBuffer()    // 序列化: opcode + body
  → AService.Send(session.Id, memoryBuffer)    // Service 查字典
  → Channel.Send(memoryBuffer)                 // Channel 写缓冲 → Socket 发送
```

**接收路径（自下而上）：**

```
Socket 收到字节
  → Channel.HandleRecv() → PacketParser 切完整包
  → AService.ReadCallback(channelId, buffer)   // 回调上抛
  = NetComponent.OnRead(channelId, buffer)      // Entity 层接管
  → GetChild<Session>(channelId)               // 用 channelId 找到 Session
  → 反序列化 → EventSystem.Invoke(SceneType)   // 按场景类型分发到业务
```

**连接创建（服务端 Accept）：**

```
底层 Socket Accept
  → Service 创建 Channel，分配 channelId
  → AcceptCallback(channelId, remoteEP)
  = NetComponent.OnAccept()
  → AddChildWithId<Session>(channelId, AService)   // Session.Id = channelId
```

---

# 五、为什么这样设计

|设计决策|原因|
|---|---|
|Channel 不知道 Session 存在|网络层可独立复用，不依赖 Entity 框架|
|Session 不持有 Channel 引用|通过 Id 间接关联，避免跨层强耦合|
|Service 用回调而非接口|比起 `INetHandler` 接口，`Action` 回调更灵活，适配 NetComponent 和 ProcessOuterSender 两种上层使用者|
|channelId 全局唯一|同进程多 Service 共存时不冲突（NetServices 统一分配）|
|Session 作为 Entity 子实体|可挂载子组件（超时检测、心跳、玩家绑定），融入 ET 的组件式设计|
|Inner / Outer 双 ServiceType|包格式不同（Inner 多 ActorId 用于 Fiber 路由），安全策略不同，但共享同一套 Service/Channel 代码|

总结：**Channel 管字节，Service 管连接池，Session 管业务语义**。三层通过 channelId + 回调松耦合，既保证了网络层的独立性，又让上层业务可以用 Entity/Component 模式管理连接。