---
tags:
  - 数据结构
  - 冒泡排序
  - 选择排序
  - 插入排序
  - 希尔排序
  - 快速排序
  - 归并排序
  - 堆排序
---

# 排序的分类


![|690](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

[![|700](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)
# 冒泡排序

基于交换的排序。每轮查找序列中的最大值，然后将其放到序列尾部。


![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

```Cpp
template<typename T>
void BubbleSort(T* array, unsigned int length) {
	if (length <= 1) {
		return;
	}

	int swap = 1;
	while (length-- && swap)
	{
		swap = 0;
		for (size_t i = 0; i < length; i++)
		{
			if (array[i] > array[i + 1]) {
				swap = 1;
				std::swap(array[i], array[i+1]);
			}
		}
	}
}
```
这里加了一个`swap`变量，用于优化冒泡排序。因为在排序的过程中，如果某一阶段，整个序列已经有序了，这个时候，冒泡排序后面的执行就都是没有意义的。使用`swap`变量，可以在`length`指针前进的时候，知道上一轮循环是否有交换产生，如果上一轮循环没有任何交换产生，就意味着，该序列从开始到上一轮结束的位置，都是有序，又因为序列的后一段也是有序的，因此整个序列都是有序的。

# 选择排序

选择排序的时间复杂度是$O(n^2)$，适用于数据量比较小的情况下。

选择排序的基本思想还是冒泡排序。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。

![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

```Cpp
template<typename T>
void SelectionSort(T array[], unsigned int length) {
	if (length <= 1) {
		return;
	}

	unsigned i = 0, j = 0, k = 0;
	while (i < length)
	{
		k = i;
		for (size_t j = i + 1; j < length; j++)
		{
			if (array[j] < array[k]) {
				k = j;
			}
		}
		std::swap(array[i], array[k]);
		i++;
	}
}
```
指针`i`用于记录已排序序列的末尾。指针`k`用于标记未排序序列中的最小值的位置。

# 插入排序

对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- 将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

![|700](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)
