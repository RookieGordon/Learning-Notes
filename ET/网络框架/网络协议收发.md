---
tags:
  - ET
---
# 客户端收发消息
`ProcessInnerSender`是用于网络消息收发的组件，挂在`Root Scene`节点上
```CSharp
public int RpcId;
public readonly Dictionary<int, MessageSenderStruct> requestCallback = new();
public readonly List<MessageInfo> list = new();
```
`RpcId`用于标记发送的[[ProcessInnerSender#ActorId和Adress结构体|`Actor`]]的`RpcId`，该值是自增的，确保每个`Actor`的`RpcId`不重复。
`ClientSenderComponent`是客户端使用的网络消息发送组件，挂在`Root Scene`节点上。是对`ProcessInnerSender`发送网络消息功能的封装。
```CSharp
[ComponentOf(typeof(Scene))]
public class ClientSenderComponent: Entity, IAwake, IDestroy
{
    public int fiberId;
    public ActorId netClientActorId;
}
```
该组件封装了`Call`和`Send`两个发送协议的方法。
## Call和Send发送Actor消息
```CSharp
public static async ETTask<IResponse> Call(
                this ProcessInnerSender self,
                ActorId actorId,
                IRequest request,
                bool needException = true)
{
    int rpcId = self.GetRpcId();
    request.RpcId = rpcId;
    Fiber fiber = self.Fiber();
    // 做一些检查
    Type requestType = request.GetType();
    IResponse response;
    if (!self.SendInner(actorId, (MessageObject)request))  // 纤程不存在
    {
        response = MessageHelper.CreateResponse(requestType, 
                                                rpcId, 
                                                ErrorCore.ERR_NotFoundActor);
        return response;
    }
            
    MessageSenderStruct messageSenderStruct = new(actorId, 
                                                  requestType, 
                                                  needException);
    self.requestCallback.Add(rpcId, messageSenderStruct);
    async ETTask Timeout()
    {
        .....
    }
            
    Timeout().Coroutine();
    response = await messageSenderStruct.Wait();
    return response;
}
```
`Call`用于有回包的`Actor`消息的发送，并且只能发往同一个进程。
`SendInner`方法，会使用`MessageQueue`单例对象，将需要发送的消息，添加到队列中去。
创建一个[[ProcessInnerSender#MessageSenderStruct结构体|`MessageSenderStruct`结构体]]，放到`requestCallback`字典中，用于等待回包，
`Send`方法因为不需要等待回包，相对简单，直接调用`SendInner`方法，将需要发送的内容添加到发送队列中
`MessageQueue`中的消息是根据`Fiber`的Id进行分类存储的。`ProcessInnerSender.Update`方法中，会获取当前`Root Scene Fiber`中，是否有待发送的消息队列，如果有则遍历每个消息，调用`HandleMessage`方法
```CSharp
private static void HandleMessage(this ProcessInnerSender self, 
                                   Fiber fiber, 
                                   in MessageInfo messageInfo)  
{  
    if (messageInfo.MessageObject is IResponse response)  
    {        
        self.HandleIActorResponse(response);  
        return;  
    }  
    
    ActorId actorId = messageInfo.ActorId;  
    MessageObject message = messageInfo.MessageObject;  
  
    MailBoxComponent mailBoxComponent 
                                = self.Fiber().Mailboxes.Get(actorId.InstanceId);  
    if (mailBoxComponent == null)  
    {        
        // 非法情形处理
    }    
    mailBoxComponent.Add(actorId.Address, message);  
}
```
`HandleMessage`方法中，如果一个消息是回包类型，那么会使用`HandleIActorResponse`另外处理，请求的协议，会获取到`Root Scene Fiber`的邮箱组件`MailBoxComponent`，通过其将协议发送出去。
`HandleIActorResponse`方法中，会根据`RpcId`来获取对应请求协议创建的`MessageSenderStruct`对象，设置其Task完成。
> `ActorId`用于记录一个消息的具体从哪个`Fiber`发送到哪个`Fiber`。
